-- Net CSR___Lab2___Part1 - IOPT
-- Automatic code generated by IOPT2VHDL XSLT transformation.
-- by GRES Research Group - 2014 


Library IEEE;
Use IEEE.STD_LOGIC_1164.ALL;
Use IEEE.STD_LOGIC_ARITH.ALL;
Use IEEE.STD_LOGIC_UNSIGNED.ALL;


Entity CSR___Lab2___Part1 IS
Port(
    Clk : IN STD_LOGIC;
    a : IN STD_LOGIC;
    b : IN STD_LOGIC;
    c : IN STD_LOGIC;
    d : IN STD_LOGIC;
    e : IN STD_LOGIC;
    k : OUT STD_LOGIC;
    l : OUT STD_LOGIC;
    m : OUT STD_LOGIC;
    Enable : IN STD_LOGIC;
    Reset : IN STD_LOGIC
);
End CSR___Lab2___Part1;

Architecture Structural OF CSR___Lab2___Part1 IS

    Signal p_2: INTEGER RANGE 0 TO 1 := 1;
    Signal p_3: INTEGER RANGE 0 TO 3 := 0;
    Signal p_4: INTEGER RANGE 0 TO 3 := 0;
    Signal p_9: INTEGER RANGE 0 TO 3 := 0;
    Signal p_10: INTEGER RANGE 0 TO 3 := 0;
    Signal p_14: INTEGER RANGE 0 TO 3 := 0;
    Signal p_19: INTEGER RANGE 0 TO 3 := 0;
    Signal p_20: INTEGER RANGE 0 TO 3 := 0;
    Signal p_22: INTEGER RANGE 0 TO 3 := 0;
    Signal p_24: INTEGER RANGE 0 TO 3 := 0;
    Signal p_59: INTEGER RANGE 0 TO 3 := 0;


    Signal s_k : STD_LOGIC := '0';
    Signal s_l : STD_LOGIC := '0';
    Signal s_m : STD_LOGIC := '0';

    -- Array implementation:

Begin
    -- Selected array items:

    proc_in_events: PROCESS( Clk, Enable ) IS
    Begin
      If falling_edge(Clk) Then
        If Reset = '0' AND Enable = '1' Then
        End If;
      End If;
    End PROCESS;


    proc_transitions: PROCESS( Clk, Enable, Reset ) IS
      Variable p_2_add, p_2_avail : INTEGER RANGE 0 to 1;
      Variable p_3_add, p_3_avail : INTEGER RANGE 0 to 3;
      Variable p_4_add, p_4_avail : INTEGER RANGE 0 to 3;
      Variable p_9_add, p_9_avail : INTEGER RANGE 0 to 3;
      Variable p_10_add, p_10_avail : INTEGER RANGE 0 to 3;
      Variable p_14_add, p_14_avail : INTEGER RANGE 0 to 3;
      Variable p_19_add, p_19_avail : INTEGER RANGE 0 to 3;
      Variable p_20_add, p_20_avail : INTEGER RANGE 0 to 3;
      Variable p_22_add, p_22_avail : INTEGER RANGE 0 to 3;
      Variable p_24_add, p_24_avail : INTEGER RANGE 0 to 3;
      Variable p_59_add, p_59_avail : INTEGER RANGE 0 to 3;
    Begin
      If Reset = '1' Then
          p_2 <= 1;
          p_3 <= 0;
          p_4 <= 0;
          p_9 <= 0;
          p_10 <= 0;
          p_14 <= 0;
          p_19 <= 0;
          p_20 <= 0;
          p_22 <= 0;
          p_24 <= 0;
          p_59 <= 0;
      Elsif rising_edge(Clk) Then
        If Enable = '1' Then
          p_2_avail := p_2;
          p_2_add := 0;   -- A0;
          p_3_avail := p_3;
          p_3_add := 0;   -- A2;
          p_4_avail := p_4;
          p_4_add := 0;   -- A1;
          p_9_avail := p_9;
          p_9_add := 0;   -- A3;
          p_10_avail := p_10;
          p_10_add := 0;   -- C0;
          p_14_avail := p_14;
          p_14_add := 0;   -- B0;
          p_19_avail := p_19;
          p_19_add := 0;   -- B2;
          p_20_avail := p_20;
          p_20_add := 0;   -- B1;
          p_22_avail := p_22;
          p_22_add := 0;   -- C2;
          p_24_avail := p_24;
          p_24_add := 0;   -- C1;
          p_59_avail := p_59;
          p_59_add := 0;   -- A4;


          -- Transition 5 - tr_5
          If (p_2_avail >= 1) and 
             (conv_integer(a) = 1) -- guard expr 
          Then
              p_2_avail := p_2_avail - 1;    -- A0
              p_4_add := p_4_add + 1;   -- A1
          End If;

          -- Transition 6 - tr_6
          If (p_3_avail >= 1) and 
             (conv_integer(a) = 0) -- guard expr 
          Then
              p_3_avail := p_3_avail - 1;    -- A2
              p_2_add := p_2_add + 1;   -- A0
          End If;

          -- Transition 7 - tr_7
          If (p_3_avail >= 1) and 
             (conv_integer(a) = 1) -- guard expr 
          Then
              p_3_avail := p_3_avail - 1;    -- A2
              p_4_add := p_4_add + 1;   -- A1
          End If;

          -- Transition 8 - tr_8
          If (p_4_avail >= 1) and 
             (conv_integer(b) = 0) -- guard expr 
          Then
              p_4_avail := p_4_avail - 1;    -- A1
              p_3_add := p_3_add + 1;   -- A2
          End If;

          -- Transition 11 - tr_11
          If (p_4_avail >= 1) and 
             (conv_integer(b) = 1 AND conv_integer(c) = 0) -- guard expr 
          Then
              p_4_avail := p_4_avail - 1;    -- A1
              p_9_add := p_9_add + 1;   -- A3
          End If;

          -- Transition 13 - tr_13
          If (p_9_avail >= 1)
          Then
              p_9_avail := p_9_avail - 1;    -- A3
              p_14_add := p_14_add + 1;   -- B0
          End If;

          -- Transition 15 - tr_15
          If (p_19_avail >= 1) and 
             (conv_integer(d) = 0) -- guard expr 
          Then
              p_19_avail := p_19_avail - 1;    -- B2
              p_14_add := p_14_add + 1;   -- B0
          End If;

          -- Transition 16 - tr_16
          If (p_14_avail >= 1)
          Then
              p_14_avail := p_14_avail - 1;    -- B0
              p_20_add := p_20_add + 1;   -- B1
          End If;

          -- Transition 17 - tr_17
          If (p_19_avail >= 1) and 
             (conv_integer(d) = 1) -- guard expr 
          Then
              p_19_avail := p_19_avail - 1;    -- B2
              p_20_add := p_20_add + 1;   -- B1
          End If;

          -- Transition 18 - tr_18
          If (p_20_avail >= 1)
          Then
              p_20_avail := p_20_avail - 1;    -- B1
              p_19_add := p_19_add + 1;   -- B2
          End If;

          -- Transition 21 - tr_21
          If (p_22_avail >= 1) and 
             (conv_integer(e) = 0) -- guard expr 
          Then
              p_22_avail := p_22_avail - 1;    -- C2
              p_10_add := p_10_add + 1;   -- C0
          End If;

          -- Transition 23 - tr_23
          If (p_10_avail >= 1)
          Then
              p_10_avail := p_10_avail - 1;    -- C0
              p_24_add := p_24_add + 1;   -- C1
          End If;

          -- Transition 25 - tr_25
          If (p_22_avail >= 1) and 
             (conv_integer(e) = 1) -- guard expr 
          Then
              p_22_avail := p_22_avail - 1;    -- C2
              p_24_add := p_24_add + 1;   -- C1
          End If;

          -- Transition 26 - tr_26
          If (p_24_avail >= 1)
          Then
              p_24_avail := p_24_avail - 1;    -- C1
              p_22_add := p_22_add + 1;   -- C2
          End If;

          -- Transition 60 - tr_60
          If (p_4_avail >= 1) and 
             (conv_integer(b) = 1 AND conv_integer(c) = 1) -- guard expr 
          Then
              p_4_avail := p_4_avail - 1;    -- A1
              p_59_add := p_59_add + 1;   -- A4
          End If;

          -- Transition 61 - tr_61
          If (p_59_avail >= 1)
          Then
              p_59_avail := p_59_avail - 1;    -- A4
              p_10_add := p_10_add + 1;   -- C0
          End If;

          -- Transition 66 - tr_66
          If (p_2_avail >= 1) and 
             (conv_integer(a) = 0) -- guard expr 
          Then
              p_2_avail := p_2_avail - 1;    -- A0
              p_2_add := p_2_add + 1;   -- A0
          End If;

          -- Calculate final place marking:
          p_2 <= p_2_avail + p_2_add;
          p_3 <= p_3_avail + p_3_add;
          p_4 <= p_4_avail + p_4_add;
          p_9 <= p_9_avail + p_9_add;
          p_10 <= p_10_avail + p_10_add;
          p_14 <= p_14_avail + p_14_add;
          p_19 <= p_19_avail + p_19_add;
          p_20 <= p_20_avail + p_20_add;
          p_22 <= p_22_avail + p_22_add;
          p_24 <= p_24_avail + p_24_add;
          p_59 <= p_59_avail + p_59_add;

          -- Apply output events to ouput signals:

          -- Calculate transition-action-output final values:
        End If;
      End If;
    End PROCESS;


    proc_place_outputs: PROCESS( Clk, Enable ) IS
    Variable exp_res, new_value: Integer;
    Begin
      If rising_edge(Clk) Then
        If Reset='1' Then
          s_k <= '0';
          s_l <= '0';
          s_m <= '0';

        Elsif Enable='1' Then

          -- Signal k default value:
          new_value := 0;

          -- k action on place A0(p_2)
          If p_2 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- k action on place A1(p_4)
          If p_4 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- k action on place A2(p_3)
          If p_3 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- k action on place A3(p_9)
          If p_9 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- k action on place A4(p_59)
          If p_59 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store k and check result range:
          If new_value < 0 Then s_k <= '0';
            Elsif new_value > 1 Then s_k <= '1';
            Else s_k <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal l default value:
          new_value := 0;

          -- l action on place B0(p_14)
          If p_14 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- l action on place B1(p_20)
          If p_20 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- l action on place B2(p_19)
          If p_19 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store l and check result range:
          If new_value < 0 Then s_l <= '0';
            Elsif new_value > 1 Then s_l <= '1';
            Else s_l <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal m default value:
          new_value := 0;

          -- m action on place C0(p_10)
          If p_10 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- m action on place C1(p_24)
          If p_24 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- m action on place C2(p_22)
          If p_22 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store m and check result range:
          If new_value < 0 Then s_m <= '0';
            Elsif new_value > 1 Then s_m <= '1';
            Else s_m <= conv_std_logic_vector(new_value,1)(0);
          End If;

        End If;
      End If;
    End PROCESS;

    k <= s_k;
    l <= s_l;
    m <= s_m;

End Structural;
