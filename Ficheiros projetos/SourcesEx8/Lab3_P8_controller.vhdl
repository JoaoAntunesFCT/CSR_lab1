-- Net CSR___Lab_3___Part1 - IOPT
-- Automatic code generated by IOPT2VHDL XSLT transformation.
-- by GRES Research Group - 2014 


Library IEEE;
Use IEEE.STD_LOGIC_1164.ALL;
Use IEEE.STD_LOGIC_ARITH.ALL;
Use IEEE.STD_LOGIC_UNSIGNED.ALL;


Entity CSR___Lab_3___Part1 IS
Port(
    Clk : IN STD_LOGIC;
    out1 : IN STD_LOGIC;
    in1 : IN STD_LOGIC;
    in2 : IN STD_LOGIC;
    in3 : IN STD_LOGIC;
    out2 : IN STD_LOGIC;
    out3 : IN STD_LOGIC;
    in4 : IN STD_LOGIC;
    movei : OUT STD_LOGIC;
    Bot1 : OUT STD_LOGIC;
    movei_4 : OUT STD_LOGIC;
    Bot1_2 : OUT STD_LOGIC;
    movei_5 : OUT STD_LOGIC;
    Bot1_3 : OUT STD_LOGIC;
    Enable : IN STD_LOGIC;
    Reset : IN STD_LOGIC
);
End CSR___Lab_3___Part1;

Architecture Structural OF CSR___Lab_3___Part1 IS

    Signal p_4: INTEGER RANGE 0 TO 3 := 0;
    Signal p_5: INTEGER RANGE 0 TO 3 := 1;
    Signal p_6: INTEGER RANGE 0 TO 3 := 0;
    Signal p_8: INTEGER RANGE 0 TO 3 := 0;
    Signal p_36_9: INTEGER RANGE 0 TO 3 := 0;
    Signal p_43: INTEGER RANGE 0 TO 3 := 3;
    Signal p_46: INTEGER RANGE 0 TO 3 := 0;
    Signal p_61: INTEGER RANGE 0 TO 3 := 1;
    Signal p_69: INTEGER RANGE 0 TO 3 := 0;
    Signal p_72: INTEGER RANGE 0 TO 1 := 0;
    Signal p_74: INTEGER RANGE 0 TO 1 := 1;
    Signal p_89_4: INTEGER RANGE 0 TO 3 := 0;
    Signal p_89_6: INTEGER RANGE 0 TO 3 := 0;
    Signal p_89_8: INTEGER RANGE 0 TO 3 := 0;
    Signal p_89_43: INTEGER RANGE 0 TO 3 := 3;
    Signal p_89_46: INTEGER RANGE 0 TO 3 := 0;
    Signal p_89_69: INTEGER RANGE 0 TO 3 := 0;
    Signal p_89_72: INTEGER RANGE 0 TO 1 := 0;
    Signal p_89_74: INTEGER RANGE 0 TO 1 := 1;
    Signal p_89_78: INTEGER RANGE 0 TO 3 := 1;
    Signal p_90_4: INTEGER RANGE 0 TO 3 := 0;
    Signal p_90_6: INTEGER RANGE 0 TO 3 := 0;
    Signal p_90_8: INTEGER RANGE 0 TO 3 := 0;
    Signal p_90_43: INTEGER RANGE 0 TO 3 := 3;
    Signal p_90_46: INTEGER RANGE 0 TO 3 := 0;
    Signal p_90_69: INTEGER RANGE 0 TO 3 := 0;
    Signal p_90_72: INTEGER RANGE 0 TO 1 := 0;
    Signal p_90_74: INTEGER RANGE 0 TO 1 := 1;
    Signal p_90_78: INTEGER RANGE 0 TO 3 := 1;

    Signal prev_out1: STD_LOGIC := '0';
    Signal prev_in1: STD_LOGIC := '0';
    Signal prev_in2: STD_LOGIC := '0';
    Signal prev_in3: STD_LOGIC := '0';
    Signal prev_out2: STD_LOGIC := '0';
    Signal prev_out3: STD_LOGIC := '0';
    Signal prev_in4: STD_LOGIC := '0';

    Signal event_outi: STD_LOGIC := '0';
    Signal event_in1: STD_LOGIC := '0';
    Signal event_in2: STD_LOGIC := '0';
    Signal event_in3: STD_LOGIC := '0';
    Signal event_out2: STD_LOGIC := '0';
    Signal event_out3: STD_LOGIC := '0';
    Signal event_in4: STD_LOGIC := '0';

    Signal s_movei : STD_LOGIC := '0';
    Signal s_Bot1 : STD_LOGIC := '0';
    Signal s_movei_4 : STD_LOGIC := '0';
    Signal s_Bot1_2 : STD_LOGIC := '0';
    Signal s_movei_5 : STD_LOGIC := '0';
    Signal s_Bot1_3 : STD_LOGIC := '0';

    -- Array implementation:

Begin
    -- Selected array items:

    proc_in_events: PROCESS( Clk, Enable ) IS
    Begin
      If falling_edge(Clk) Then
        If Reset = '0' AND Enable = '1' Then
          If (prev_out1 = '0') and (out1 = '1')
            Then event_outi <= '1';
            Else event_outi <= '0';
          End If;
          If (prev_in1 = '0') and (in1 = '1')
            Then event_in1 <= '1';
            Else event_in1 <= '0';
          End If;
          If (prev_in2 = '0') and (in2 = '1')
            Then event_in2 <= '1';
            Else event_in2 <= '0';
          End If;
          If (prev_in3 = '0') and (in3 = '1')
            Then event_in3 <= '1';
            Else event_in3 <= '0';
          End If;
          If (prev_out2 = '0') and (out2 = '1')
            Then event_out2 <= '1';
            Else event_out2 <= '0';
          End If;
          If (prev_out3 = '0') and (out3 = '1')
            Then event_out3 <= '1';
            Else event_out3 <= '0';
          End If;
          If (prev_in4 = '0') and (in4 = '1')
            Then event_in4 <= '1';
            Else event_in4 <= '0';
          End If;
        End If;
        prev_out1 <= out1;
        prev_in1 <= in1;
        prev_in2 <= in2;
        prev_in3 <= in3;
        prev_out2 <= out2;
        prev_out3 <= out3;
        prev_in4 <= in4;
      End If;
    End PROCESS;


    proc_transitions: PROCESS( Clk, Enable, Reset ) IS
      Variable p_4_add, p_4_avail : INTEGER RANGE 0 to 3;
      Variable p_5_add, p_5_avail : INTEGER RANGE 0 to 3;
      Variable p_6_add, p_6_avail : INTEGER RANGE 0 to 3;
      Variable p_8_add, p_8_avail : INTEGER RANGE 0 to 3;
      Variable p_36_9_add, p_36_9_avail : INTEGER RANGE 0 to 3;
      Variable p_43_add, p_43_avail : INTEGER RANGE 0 to 3;
      Variable p_46_add, p_46_avail : INTEGER RANGE 0 to 3;
      Variable p_61_add, p_61_avail : INTEGER RANGE 0 to 3;
      Variable p_69_add, p_69_avail : INTEGER RANGE 0 to 3;
      Variable p_72_add, p_72_avail : INTEGER RANGE 0 to 1;
      Variable p_74_add, p_74_avail : INTEGER RANGE 0 to 1;
      Variable p_89_4_add, p_89_4_avail : INTEGER RANGE 0 to 3;
      Variable p_89_6_add, p_89_6_avail : INTEGER RANGE 0 to 3;
      Variable p_89_8_add, p_89_8_avail : INTEGER RANGE 0 to 3;
      Variable p_89_43_add, p_89_43_avail : INTEGER RANGE 0 to 3;
      Variable p_89_46_add, p_89_46_avail : INTEGER RANGE 0 to 3;
      Variable p_89_69_add, p_89_69_avail : INTEGER RANGE 0 to 3;
      Variable p_89_72_add, p_89_72_avail : INTEGER RANGE 0 to 1;
      Variable p_89_74_add, p_89_74_avail : INTEGER RANGE 0 to 1;
      Variable p_89_78_add, p_89_78_avail : INTEGER RANGE 0 to 3;
      Variable p_90_4_add, p_90_4_avail : INTEGER RANGE 0 to 3;
      Variable p_90_6_add, p_90_6_avail : INTEGER RANGE 0 to 3;
      Variable p_90_8_add, p_90_8_avail : INTEGER RANGE 0 to 3;
      Variable p_90_43_add, p_90_43_avail : INTEGER RANGE 0 to 3;
      Variable p_90_46_add, p_90_46_avail : INTEGER RANGE 0 to 3;
      Variable p_90_69_add, p_90_69_avail : INTEGER RANGE 0 to 3;
      Variable p_90_72_add, p_90_72_avail : INTEGER RANGE 0 to 1;
      Variable p_90_74_add, p_90_74_avail : INTEGER RANGE 0 to 1;
      Variable p_90_78_add, p_90_78_avail : INTEGER RANGE 0 to 3;
    Begin
      If Reset = '1' Then
          p_4 <= 0;
          p_5 <= 1;
          p_6 <= 0;
          p_8 <= 0;
          p_36_9 <= 0;
          p_43 <= 3;
          p_46 <= 0;
          p_61 <= 1;
          p_69 <= 0;
          p_72 <= 0;
          p_74 <= 1;
          p_89_4 <= 0;
          p_89_6 <= 0;
          p_89_8 <= 0;
          p_89_43 <= 3;
          p_89_46 <= 0;
          p_89_69 <= 0;
          p_89_72 <= 0;
          p_89_74 <= 1;
          p_89_78 <= 1;
          p_90_4 <= 0;
          p_90_6 <= 0;
          p_90_8 <= 0;
          p_90_43 <= 3;
          p_90_46 <= 0;
          p_90_69 <= 0;
          p_90_72 <= 0;
          p_90_74 <= 1;
          p_90_78 <= 1;
      Elsif rising_edge(Clk) Then
        If Enable = '1' Then
          p_4_avail := p_4;
          p_4_add := 0;   -- pl_4;
          p_5_avail := p_5;
          p_5_add := 0;   -- pl_5;
          p_6_avail := p_6;
          p_6_add := 0;   -- Processar Peca;
          p_8_avail := p_8;
          p_8_add := 0;   -- pl_8;
          p_36_9_avail := p_36_9;
          p_36_9_add := 0;   -- pl_9_3;
          p_43_avail := p_43;
          p_43_add := 0;   -- Pecas;
          p_46_avail := p_46;
          p_46_add := 0;   -- Buffer;
          p_61_avail := p_61;
          p_61_add := 0;   -- ppb_3;
          p_69_avail := p_69;
          p_69_add := 0;   -- Move;
          p_72_avail := p_72;
          p_72_add := 0;   -- Parado & Ocupado;
          p_74_avail := p_74;
          p_74_add := 0;   -- Parado & Livre;
          p_89_4_avail := p_89_4;
          p_89_4_add := 0;   -- pl_4_4;
          p_89_6_avail := p_89_6;
          p_89_6_add := 0;   -- Processar Peca_2;
          p_89_8_avail := p_89_8;
          p_89_8_add := 0;   -- pl_8_4;
          p_89_43_avail := p_89_43;
          p_89_43_add := 0;   -- Pecas_2;
          p_89_46_avail := p_89_46;
          p_89_46_add := 0;   -- Buffer_2;
          p_89_69_avail := p_89_69;
          p_89_69_add := 0;   -- Move_2;
          p_89_72_avail := p_89_72;
          p_89_72_add := 0;   -- Parado & Ocupado_2;
          p_89_74_avail := p_89_74;
          p_89_74_add := 0;   -- Parado & Livre_2;
          p_89_78_avail := p_89_78;
          p_89_78_add := 0;   -- pl_78_2;
          p_90_4_avail := p_90_4;
          p_90_4_add := 0;   -- pl_4_5;
          p_90_6_avail := p_90_6;
          p_90_6_add := 0;   -- Processar Peca_3;
          p_90_8_avail := p_90_8;
          p_90_8_add := 0;   -- pl_8_5;
          p_90_43_avail := p_90_43;
          p_90_43_add := 0;   -- Pecas_3;
          p_90_46_avail := p_90_46;
          p_90_46_add := 0;   -- Buffer_3;
          p_90_69_avail := p_90_69;
          p_90_69_add := 0;   -- Move_3;
          p_90_72_avail := p_90_72;
          p_90_72_add := 0;   -- Parado & Ocupado_3;
          p_90_74_avail := p_90_74;
          p_90_74_add := 0;   -- Parado & Livre_3;
          p_90_78_avail := p_90_78;
          p_90_78_add := 0;   -- pl_78_3;


          -- Transition 10 - OUT1
          If (p_69_avail >= 1) and
             (event_outi = '1') and 
             (conv_integer(out1) = 1) -- guard expr 
          Then
              p_69_avail := p_69_avail - 1;    -- Move
              p_4_add := p_4_add + 1;   -- pl_4
              p_72_add := p_72_add + 1;   -- Parado & Ocupado
          End If;

          -- Transition 11 - tr_11
          If (p_4_avail >= 1) and
             (p_5_avail >= 1) and 
             (conv_integer(out1) = 1) -- guard expr 
          Then
              p_4_avail := p_4_avail - 1;    -- pl_4
              p_5_avail := p_5_avail - 1;    -- pl_5
              p_6_add := p_6_add + 1;   -- Processar Peca
          End If;

          -- Transition 12 - tr_12
          If (p_6_avail >= 1) and
             (p_72_avail >= 1) and 
             (conv_integer(out1) = 0) -- guard expr 
          Then
              p_6_avail := p_6_avail - 1;    -- Processar Peca
              p_72_avail := p_72_avail - 1;    -- Parado & Ocupado
              p_8_add := p_8_add + 1;   -- pl_8
              p_43_add := p_43_add + 1;   -- Pecas
              p_74_add := p_74_add + 1;   -- Parado & Livre
          End If;

          -- Transition 36_13 - tr_13_3
          If (p_61_avail >= 1) and
             (p_90_8_avail >= 1) and 
             (conv_integer(in4) = 1) -- guard expr 
          Then
              p_61_avail := p_61_avail - 1;    -- ppb_3
              p_90_8_avail := p_90_8_avail - 1;    -- pl_8_5
              p_36_9_add := p_36_9_add + 1;   -- pl_9_3
          End If;

          -- Transition 36_25 - tr_25_3
          If (p_36_9_avail >= 1) and 
             (conv_integer(in4) = 1) -- guard expr 
          Then
              p_36_9_avail := p_36_9_avail - 1;    -- pl_9_3
              p_61_add := p_61_add + 1;   -- ppb_3
              p_90_78_add := p_90_78_add + 1;   -- pl_78_3
          End If;

          -- Transition 39 - tr_39
          If (p_43_avail >= 1) and
             (event_in1 = '1')
          Then
              p_43_avail := p_43_avail - 1;    -- Pecas
              p_46_add := p_46_add + 1;   -- Buffer
          End If;

          -- Transition 67 - tr_67
          If (p_46_avail >= 1) and
             (p_74_avail >= 1)
          Then
              p_46_avail := p_46_avail - 1;    -- Buffer
              p_74_avail := p_74_avail - 1;    -- Parado & Livre
              p_69_add := p_69_add + 1;   -- Move
          End If;

          -- Transition 89_10 - OUT1_2
          If (p_89_69_avail >= 1) and
             (event_out2 = '1') and 
             (conv_integer(out2) = 1) -- guard expr 
          Then
              p_89_69_avail := p_89_69_avail - 1;    -- Move_2
              p_89_4_add := p_89_4_add + 1;   -- pl_4_4
              p_89_72_add := p_89_72_add + 1;   -- Parado & Ocupado_2
          End If;

          -- Transition 89_11 - tr_11_4
          If (p_89_4_avail >= 1) and
             (p_89_78_avail >= 1) and 
             (conv_integer(out2) = 1) -- guard expr 
          Then
              p_89_4_avail := p_89_4_avail - 1;    -- pl_4_4
              p_89_78_avail := p_89_78_avail - 1;    -- pl_78_2
              p_89_6_add := p_89_6_add + 1;   -- Processar Peca_2
          End If;

          -- Transition 89_12 - tr_12_4
          If (p_89_6_avail >= 1) and
             (p_89_72_avail >= 1) and 
             (conv_integer(out2) = 0) -- guard expr 
          Then
              p_89_6_avail := p_89_6_avail - 1;    -- Processar Peca_2
              p_89_72_avail := p_89_72_avail - 1;    -- Parado & Ocupado_2
              p_89_8_add := p_89_8_add + 1;   -- pl_8_4
              p_89_43_add := p_89_43_add + 1;   -- Pecas_2
              p_89_74_add := p_89_74_add + 1;   -- Parado & Livre_2
          End If;

          -- Transition 89_39 - tr_39_2
          If (p_89_43_avail >= 1) and
             (p_8_avail >= 1) and
             (event_in2 = '1')
          Then
              p_89_43_avail := p_89_43_avail - 1;    -- Pecas_2
              p_8_avail := p_8_avail - 1;    -- pl_8
              p_89_46_add := p_89_46_add + 1;   -- Buffer_2
          End If;

          -- Transition 89_67 - tr_67_2
          If (p_89_46_avail >= 1) and
             (p_89_74_avail >= 1)
          Then
              p_89_46_avail := p_89_46_avail - 1;    -- Buffer_2
              p_89_74_avail := p_89_74_avail - 1;    -- Parado & Livre_2
              p_89_69_add := p_89_69_add + 1;   -- Move_2
              p_5_add := p_5_add + 1;   -- pl_5
          End If;

          -- Transition 90_10 - OUT1_3
          If (p_90_69_avail >= 1) and
             (event_out3 = '1') and 
             (conv_integer(out3) = 1) -- guard expr 
          Then
              p_90_69_avail := p_90_69_avail - 1;    -- Move_3
              p_90_4_add := p_90_4_add + 1;   -- pl_4_5
              p_90_72_add := p_90_72_add + 1;   -- Parado & Ocupado_3
          End If;

          -- Transition 90_11 - tr_11_5
          If (p_90_4_avail >= 1) and
             (p_90_78_avail >= 1) and 
             (conv_integer(out3) = 1) -- guard expr 
          Then
              p_90_4_avail := p_90_4_avail - 1;    -- pl_4_5
              p_90_78_avail := p_90_78_avail - 1;    -- pl_78_3
              p_90_6_add := p_90_6_add + 1;   -- Processar Peca_3
          End If;

          -- Transition 90_12 - tr_12_5
          If (p_90_6_avail >= 1) and
             (p_90_72_avail >= 1) and 
             (conv_integer(out3) = 0) -- guard expr 
          Then
              p_90_6_avail := p_90_6_avail - 1;    -- Processar Peca_3
              p_90_72_avail := p_90_72_avail - 1;    -- Parado & Ocupado_3
              p_90_8_add := p_90_8_add + 1;   -- pl_8_5
              p_90_43_add := p_90_43_add + 1;   -- Pecas_3
              p_90_74_add := p_90_74_add + 1;   -- Parado & Livre_3
          End If;

          -- Transition 90_39 - tr_39_3
          If (p_90_43_avail >= 1) and
             (p_89_8_avail >= 1) and
             (event_in3 = '1')
          Then
              p_90_43_avail := p_90_43_avail - 1;    -- Pecas_3
              p_89_8_avail := p_89_8_avail - 1;    -- pl_8_4
              p_90_46_add := p_90_46_add + 1;   -- Buffer_3
          End If;

          -- Transition 90_67 - tr_67_3
          If (p_90_46_avail >= 1) and
             (p_90_74_avail >= 1)
          Then
              p_90_46_avail := p_90_46_avail - 1;    -- Buffer_3
              p_90_74_avail := p_90_74_avail - 1;    -- Parado & Livre_3
              p_90_69_add := p_90_69_add + 1;   -- Move_3
              p_89_78_add := p_89_78_add + 1;   -- pl_78_2
          End If;

          -- Calculate final place marking:
          p_4 <= p_4_avail + p_4_add;
          p_5 <= p_5_avail + p_5_add;
          p_6 <= p_6_avail + p_6_add;
          p_8 <= p_8_avail + p_8_add;
          p_36_9 <= p_36_9_avail + p_36_9_add;
          p_43 <= p_43_avail + p_43_add;
          p_46 <= p_46_avail + p_46_add;
          p_61 <= p_61_avail + p_61_add;
          p_69 <= p_69_avail + p_69_add;
          p_72 <= p_72_avail + p_72_add;
          p_74 <= p_74_avail + p_74_add;
          p_89_4 <= p_89_4_avail + p_89_4_add;
          p_89_6 <= p_89_6_avail + p_89_6_add;
          p_89_8 <= p_89_8_avail + p_89_8_add;
          p_89_43 <= p_89_43_avail + p_89_43_add;
          p_89_46 <= p_89_46_avail + p_89_46_add;
          p_89_69 <= p_89_69_avail + p_89_69_add;
          p_89_72 <= p_89_72_avail + p_89_72_add;
          p_89_74 <= p_89_74_avail + p_89_74_add;
          p_89_78 <= p_89_78_avail + p_89_78_add;
          p_90_4 <= p_90_4_avail + p_90_4_add;
          p_90_6 <= p_90_6_avail + p_90_6_add;
          p_90_8 <= p_90_8_avail + p_90_8_add;
          p_90_43 <= p_90_43_avail + p_90_43_add;
          p_90_46 <= p_90_46_avail + p_90_46_add;
          p_90_69 <= p_90_69_avail + p_90_69_add;
          p_90_72 <= p_90_72_avail + p_90_72_add;
          p_90_74 <= p_90_74_avail + p_90_74_add;
          p_90_78 <= p_90_78_avail + p_90_78_add;

          -- Apply output events to ouput signals:

          -- Calculate transition-action-output final values:
        End If;
      End If;
    End PROCESS;


    proc_place_outputs: PROCESS( Clk, Enable ) IS
    Variable exp_res, new_value: Integer;
    Begin
      If rising_edge(Clk) Then
        If Reset='1' Then
          s_movei <= '0';
          s_Bot1 <= '0';
          s_movei_4 <= '0';
          s_Bot1_2 <= '0';
          s_movei_5 <= '0';
          s_Bot1_3 <= '0';

        Elsif Enable='1' Then

          -- Signal movei default value:
          new_value := 0;

          -- movei action on place Move(p_69)
          If p_69 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei and check result range:
          If new_value < 0 Then s_movei <= '0';
            Elsif new_value > 1 Then s_movei <= '1';
            Else s_movei <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot1 default value:
          new_value := 0;

          -- Bot1 action on place Processar Peca(p_6)
          If p_6 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Bot1 action on place pl_8(p_8)
          If p_8 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot1 and check result range:
          If new_value < 0 Then s_Bot1 <= '0';
            Elsif new_value > 1 Then s_Bot1 <= '1';
            Else s_Bot1 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal movei_4 default value:
          new_value := 0;

          -- movei_4 action on place Move_2(p_89_69)
          If p_89_69 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei_4 and check result range:
          If new_value < 0 Then s_movei_4 <= '0';
            Elsif new_value > 1 Then s_movei_4 <= '1';
            Else s_movei_4 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot1_2 default value:
          new_value := 0;

          -- Bot1_2 action on place Processar Peca_2(p_89_6)
          If p_89_6 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Bot1_2 action on place pl_8_4(p_89_8)
          If p_89_8 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot1_2 and check result range:
          If new_value < 0 Then s_Bot1_2 <= '0';
            Elsif new_value > 1 Then s_Bot1_2 <= '1';
            Else s_Bot1_2 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal movei_5 default value:
          new_value := 0;

          -- movei_5 action on place Move_3(p_90_69)
          If p_90_69 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei_5 and check result range:
          If new_value < 0 Then s_movei_5 <= '0';
            Elsif new_value > 1 Then s_movei_5 <= '1';
            Else s_movei_5 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot1_3 default value:
          new_value := 0;

          -- Bot1_3 action on place Processar Peca_3(p_90_6)
          If p_90_6 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Bot1_3 action on place pl_8_5(p_90_8)
          If p_90_8 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot1_3 and check result range:
          If new_value < 0 Then s_Bot1_3 <= '0';
            Elsif new_value > 1 Then s_Bot1_3 <= '1';
            Else s_Bot1_3 <= conv_std_logic_vector(new_value,1)(0);
          End If;

        End If;
      End If;
    End PROCESS;

    movei <= s_movei;
    Bot1 <= s_Bot1;
    movei_4 <= s_movei_4;
    Bot1_2 <= s_Bot1_2;
    movei_5 <= s_movei_5;
    Bot1_3 <= s_Bot1_3;

End Structural;
