-- Net CSR___Lab_3___Part1 - IOPT
-- Automatic code generated by IOPT2VHDL XSLT transformation.
-- by GRES Research Group - 2014 


Library IEEE;
Use IEEE.STD_LOGIC_1164.ALL;
Use IEEE.STD_LOGIC_ARITH.ALL;
Use IEEE.STD_LOGIC_UNSIGNED.ALL;


Entity CSR_Lab_3_Part1_TD1 IS
Port(
    Clk : IN STD_LOGIC;
    outi : IN STD_LOGIC;
    ini : IN STD_LOGIC;
    in1 : IN STD_LOGIC;
    event_event74_td_1 : IN STD_LOGIC;
    movei : OUT STD_LOGIC;
    Bot1 : OUT STD_LOGIC;
    out_evt_event71_td_2 : OUT STD_LOGIC;
    Enable : IN STD_LOGIC;
    Reset : IN STD_LOGIC
);
End CSR_Lab_3_Part1_TD1;

Architecture Structural OF CSR_Lab_3_Part1_TD1 IS

    Signal p_4: INTEGER RANGE 0 TO 1 := 0;
    Signal p_5: INTEGER RANGE 0 TO 1 := 1;
    Signal p_6: INTEGER RANGE 0 TO 1 := 0;
    Signal p_43: INTEGER RANGE 0 TO 1 := 1;
    Signal p_46: INTEGER RANGE 0 TO 1 := 0;


    Signal s_movei : STD_LOGIC := '0';
    Signal s_Bot1 : STD_LOGIC := '0';

    -- Array implementation:

Begin
    -- Selected array items:

    proc_in_events: PROCESS( Clk, Enable ) IS
    Begin
      If falling_edge(Clk) Then
        If Reset = '0' AND Enable = '1' Then
        End If;
      End If;
    End PROCESS;


    proc_transitions: PROCESS( Clk, Enable, Reset ) IS
      Variable p_4_add, p_4_avail : INTEGER RANGE 0 to 1;
      Variable p_5_add, p_5_avail : INTEGER RANGE 0 to 1;
      Variable p_6_add, p_6_avail : INTEGER RANGE 0 to 1;
      Variable p_43_add, p_43_avail : INTEGER RANGE 0 to 1;
      Variable p_46_add, p_46_avail : INTEGER RANGE 0 to 1;
    Begin
      If Reset = '1' Then
          p_4 <= 0;
          p_5 <= 1;
          p_6 <= 0;
          p_43 <= 1;
          p_46 <= 0;
      Elsif rising_edge(Clk) Then
        If Enable = '1' Then
          p_4_avail := p_4;
          p_4_add := 0;   -- pl_4;
          p_5_avail := p_5;
          p_5_add := 0;   -- pl_5;
          p_6_avail := p_6;
          p_6_add := 0;   -- pl_6;
          p_43_avail := p_43;
          p_43_add := 0;   -- pl_37;
          p_46_avail := p_46;
          p_46_add := 0;   -- pl_38;

          out_evt_event71_td_2 <= '0';

          -- Transition 10 - tr_10
          If (p_46_avail >= 1) and 
             (conv_integer(outi) = 1) -- guard expr 
          Then
              p_46_avail := p_46_avail - 1;    -- pl_38
              p_4_add := p_4_add + 1;   -- pl_4
          End If;

          -- Transition 11 - tr_11
          If (p_4_avail >= 1) and
             (p_5_avail >= 1) and 
             (conv_integer(outi) = 1) -- guard expr 
          Then
              p_4_avail := p_4_avail - 1;    -- pl_4
              p_5_avail := p_5_avail - 1;    -- pl_5
              p_6_add := p_6_add + 1;   -- pl_6
          End If;

          -- Transition 12 - tr_12
          If (p_6_avail >= 1) and 
             (conv_integer(outi) = 0) -- guard expr 
          Then
              p_6_avail := p_6_avail - 1;    -- pl_6
              p_43_add := p_43_add + 1;   -- pl_37
              out_evt_event71_td_2 <= '1';
          End If;

          -- Transition 39 - tr_39
          If (p_43_avail >= 1) and 
             (conv_integer(in1) = 1) -- guard expr 
          Then
              p_43_avail := p_43_avail - 1;    -- pl_37
              p_46_add := p_46_add + 1;   -- pl_38
          End If;

          -- Transition 69 - tr_251
          If TRUE and
             (event_event74_td_1 = '1')
          Then
              p_5_add := p_5_add + 1;   -- pl_5
          End If;

          -- Calculate final place marking:
          p_4 <= p_4_avail + p_4_add;
          p_5 <= p_5_avail + p_5_add;
          p_6 <= p_6_avail + p_6_add;
          p_43 <= p_43_avail + p_43_add;
          p_46 <= p_46_avail + p_46_add;

          -- Apply output events to ouput signals:

          -- Calculate transition-action-output final values:
        End If;
      End If;
    End PROCESS;


    proc_place_outputs: PROCESS( Clk, Enable ) IS
    Variable exp_res, new_value: Integer;
    Begin
      If rising_edge(Clk) Then
        If Reset='1' Then
          s_movei <= '0';
          s_Bot1 <= '0';

        Elsif Enable='1' Then

          -- Signal movei default value:
          new_value := 0;

          -- movei action on place pl_38(p_46)
          If p_46 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei and check result range:
          If new_value < 0 Then s_movei <= '0';
            Elsif new_value > 1 Then s_movei <= '1';
            Else s_movei <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot1 default value:
          new_value := 0;

          -- Bot1 action on place pl_6(p_6)
          If p_6 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot1 and check result range:
          If new_value < 0 Then s_Bot1 <= '0';
            Elsif new_value > 1 Then s_Bot1 <= '1';
            Else s_Bot1 <= conv_std_logic_vector(new_value,1)(0);
          End If;

        End If;
      End If;
    End PROCESS;

    movei <= s_movei;
    Bot1 <= s_Bot1;

End Structural;
