-- Net CSR___Lab_3___Part1 - IOPT
-- Automatic code generated by IOPT2VHDL XSLT transformation.
-- by GRES Research Group - 2014 


Library IEEE;
Use IEEE.STD_LOGIC_1164.ALL;
Use IEEE.STD_LOGIC_ARITH.ALL;
Use IEEE.STD_LOGIC_UNSIGNED.ALL;


Entity CSR_Lab_3_Part1_TD2 IS
Port(
    Clk : IN STD_LOGIC;
    ini : IN STD_LOGIC;
    outi_2 : IN STD_LOGIC;
    event_event71_td_2 : IN STD_LOGIC;
    event_event90_td_2 : IN STD_LOGIC;
    movei_2 : OUT STD_LOGIC;
    Bot1 : OUT STD_LOGIC;
    Bot2 : OUT STD_LOGIC;
    out_evt_event74_td_1 : OUT STD_LOGIC;
    out_evt_event87_td_3 : OUT STD_LOGIC;
    Enable : IN STD_LOGIC;
    Reset : IN STD_LOGIC
);
End CSR_Lab_3_Part1_TD2;

Architecture Structural OF CSR_Lab_3_Part1_TD2 IS

    Signal p_8: INTEGER RANGE 0 TO 1 := 0;
    Signal p_9: INTEGER RANGE 0 TO 1 := 0;
    Signal p_34_4: INTEGER RANGE 0 TO 1 := 0;
    Signal p_34_5: INTEGER RANGE 0 TO 1 := 1;
    Signal p_34_6: INTEGER RANGE 0 TO 1 := 0;
    Signal p_49: INTEGER RANGE 0 TO 1 := 0;
    Signal p_52: INTEGER RANGE 0 TO 1 := 1;


    Signal s_movei_2 : STD_LOGIC := '0';
    Signal s_Bot1 : STD_LOGIC := '0';
    Signal s_Bot2 : STD_LOGIC := '0';

    -- Array implementation:

Begin
    -- Selected array items:

    proc_in_events: PROCESS( Clk, Enable ) IS
    Begin
      If falling_edge(Clk) Then
        If Reset = '0' AND Enable = '1' Then
        End If;
      End If;
    End PROCESS;


    proc_transitions: PROCESS( Clk, Enable, Reset ) IS
      Variable p_8_add, p_8_avail : INTEGER RANGE 0 to 1;
      Variable p_9_add, p_9_avail : INTEGER RANGE 0 to 1;
      Variable p_34_4_add, p_34_4_avail : INTEGER RANGE 0 to 1;
      Variable p_34_5_add, p_34_5_avail : INTEGER RANGE 0 to 1;
      Variable p_34_6_add, p_34_6_avail : INTEGER RANGE 0 to 1;
      Variable p_49_add, p_49_avail : INTEGER RANGE 0 to 1;
      Variable p_52_add, p_52_avail : INTEGER RANGE 0 to 1;
    Begin
      If Reset = '1' Then
          p_8 <= 0;
          p_9 <= 0;
          p_34_4 <= 0;
          p_34_5 <= 1;
          p_34_6 <= 0;
          p_49 <= 0;
          p_52 <= 1;
      Elsif rising_edge(Clk) Then
        If Enable = '1' Then
          p_8_avail := p_8;
          p_8_add := 0;   -- pl_8;
          p_9_avail := p_9;
          p_9_add := 0;   -- pl_9;
          p_34_4_avail := p_34_4;
          p_34_4_add := 0;   -- pl_4_2;
          p_34_5_avail := p_34_5;
          p_34_5_add := 0;   -- pl_5_2;
          p_34_6_avail := p_34_6;
          p_34_6_add := 0;   -- pl_6_2;
          p_49_avail := p_49;
          p_49_add := 0;   -- ppb;
          p_52_avail := p_52;
          p_52_add := 0;   -- pl_32;

          out_evt_event74_td_1 <= '0';
          out_evt_event87_td_3 <= '0';

          -- Transition 13 - tr_13
          If (p_8_avail >= 1) and
             (p_52_avail >= 1) and 
             (conv_integer(ini) = 1) -- guard expr 
          Then
              p_8_avail := p_8_avail - 1;    -- pl_8
              p_52_avail := p_52_avail - 1;    -- pl_32
              p_9_add := p_9_add + 1;   -- pl_9
          End If;

          -- Transition 25 - tr_25
          If (p_9_avail >= 1) and 
             (conv_integer(ini) = 1) -- guard expr 
          Then
              p_9_avail := p_9_avail - 1;    -- pl_9
              p_49_add := p_49_add + 1;   -- ppb
              out_evt_event74_td_1 <= '1';
          End If;

          -- Transition 34_10 - tr_10_2
          If (p_49_avail >= 1) and 
             (conv_integer(outi_2) = 1) -- guard expr 
          Then
              p_49_avail := p_49_avail - 1;    -- ppb
              p_34_4_add := p_34_4_add + 1;   -- pl_4_2
          End If;

          -- Transition 34_11 - tr_11_2
          If (p_34_4_avail >= 1) and
             (p_34_5_avail >= 1) and 
             (conv_integer(outi_2) = 1) -- guard expr 
          Then
              p_34_4_avail := p_34_4_avail - 1;    -- pl_4_2
              p_34_5_avail := p_34_5_avail - 1;    -- pl_5_2
              p_34_6_add := p_34_6_add + 1;   -- pl_6_2
          End If;

          -- Transition 34_12 - tr_12_2
          If (p_34_6_avail >= 1) and 
             (conv_integer(outi_2) = 0) -- guard expr 
          Then
              p_34_6_avail := p_34_6_avail - 1;    -- pl_6_2
              p_52_add := p_52_add + 1;   -- pl_32
              out_evt_event87_td_3 <= '1';
          End If;

          -- Transition 68 - tr_121
          If TRUE and
             (event_event71_td_2 = '1')
          Then
              p_8_add := p_8_add + 1;   -- pl_8
          End If;

          -- Transition 85 - tr_25_21
          If TRUE and
             (event_event90_td_2 = '1')
          Then
              p_34_5_add := p_34_5_add + 1;   -- pl_5_2
          End If;

          -- Calculate final place marking:
          p_8 <= p_8_avail + p_8_add;
          p_9 <= p_9_avail + p_9_add;
          p_34_4 <= p_34_4_avail + p_34_4_add;
          p_34_5 <= p_34_5_avail + p_34_5_add;
          p_34_6 <= p_34_6_avail + p_34_6_add;
          p_49 <= p_49_avail + p_49_add;
          p_52 <= p_52_avail + p_52_add;

          -- Apply output events to ouput signals:

          -- Calculate transition-action-output final values:
        End If;
      End If;
    End PROCESS;


    proc_place_outputs: PROCESS( Clk, Enable ) IS
    Variable exp_res, new_value: Integer;
    Begin
      If rising_edge(Clk) Then
        If Reset='1' Then
          s_movei_2 <= '0';
          s_Bot1 <= '0';
          s_Bot2 <= '0';

        Elsif Enable='1' Then

          -- Signal movei_2 default value:
          new_value := 0;

          -- movei_2 action on place ppb(p_49)
          If p_49 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei_2 and check result range:
          If new_value < 0 Then s_movei_2 <= '0';
            Elsif new_value > 1 Then s_movei_2 <= '1';
            Else s_movei_2 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot1 default value:
          new_value := 0;

          -- Bot1 action on place pl_8(p_8)
          If p_8 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot1 and check result range:
          If new_value < 0 Then s_Bot1 <= '0';
            Elsif new_value > 1 Then s_Bot1 <= '1';
            Else s_Bot1 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot2 default value:
          new_value := 0;

          -- Bot2 action on place pl_6_2(p_34_6)
          If p_34_6 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot2 and check result range:
          If new_value < 0 Then s_Bot2 <= '0';
            Elsif new_value > 1 Then s_Bot2 <= '1';
            Else s_Bot2 <= conv_std_logic_vector(new_value,1)(0);
          End If;

        End If;
      End If;
    End PROCESS;

    movei_2 <= s_movei_2;
    Bot1 <= s_Bot1;
    Bot2 <= s_Bot2;

End Structural;
