-- Net CSR___Lab_3___Part1 - IOPT
-- Automatic code generated by IOPT2VHDL XSLT transformation.
-- by GRES Research Group - 2014 


Library IEEE;
Use IEEE.STD_LOGIC_1164.ALL;
Use IEEE.STD_LOGIC_ARITH.ALL;
Use IEEE.STD_LOGIC_UNSIGNED.ALL;


Entity CSR_Lab_3_Part1_TD3 IS
Port(
    Clk : IN STD_LOGIC;
    ini_2 : IN STD_LOGIC;
    outi_3 : IN STD_LOGIC;
    ini_3 : IN STD_LOGIC;
    event_event87_td_3 : IN STD_LOGIC;
    movei_3 : OUT STD_LOGIC;
    Bot2 : OUT STD_LOGIC;
    Bot3 : OUT STD_LOGIC;
    out_evt_event90_td_2 : OUT STD_LOGIC;
    Enable : IN STD_LOGIC;
    Reset : IN STD_LOGIC
);
End CSR_Lab_3_Part1_TD3;

Architecture Structural OF CSR_Lab_3_Part1_TD3 IS

    Signal p_34_8: INTEGER RANGE 0 TO 1 := 0;
    Signal p_34_9: INTEGER RANGE 0 TO 1 := 0;
    Signal p_36_4: INTEGER RANGE 0 TO 1 := 0;
    Signal p_36_5: INTEGER RANGE 0 TO 1 := 1;
    Signal p_36_6: INTEGER RANGE 0 TO 1 := 0;
    Signal p_36_8: INTEGER RANGE 0 TO 1 := 0;
    Signal p_36_9: INTEGER RANGE 0 TO 1 := 0;
    Signal p_55: INTEGER RANGE 0 TO 1 := 1;
    Signal p_58: INTEGER RANGE 0 TO 1 := 0;
    Signal p_61: INTEGER RANGE 0 TO 1 := 1;


    Signal s_movei_3 : STD_LOGIC := '0';
    Signal s_Bot2 : STD_LOGIC := '0';
    Signal s_Bot3 : STD_LOGIC := '0';

    -- Array implementation:

Begin
    -- Selected array items:

    proc_in_events: PROCESS( Clk, Enable ) IS
    Begin
      If falling_edge(Clk) Then
        If Reset = '0' AND Enable = '1' Then
        End If;
      End If;
    End PROCESS;


    proc_transitions: PROCESS( Clk, Enable, Reset ) IS
      Variable p_34_8_add, p_34_8_avail : INTEGER RANGE 0 to 1;
      Variable p_34_9_add, p_34_9_avail : INTEGER RANGE 0 to 1;
      Variable p_36_4_add, p_36_4_avail : INTEGER RANGE 0 to 1;
      Variable p_36_5_add, p_36_5_avail : INTEGER RANGE 0 to 1;
      Variable p_36_6_add, p_36_6_avail : INTEGER RANGE 0 to 1;
      Variable p_36_8_add, p_36_8_avail : INTEGER RANGE 0 to 1;
      Variable p_36_9_add, p_36_9_avail : INTEGER RANGE 0 to 1;
      Variable p_55_add, p_55_avail : INTEGER RANGE 0 to 1;
      Variable p_58_add, p_58_avail : INTEGER RANGE 0 to 1;
      Variable p_61_add, p_61_avail : INTEGER RANGE 0 to 1;
    Begin
      If Reset = '1' Then
          p_34_8 <= 0;
          p_34_9 <= 0;
          p_36_4 <= 0;
          p_36_5 <= 1;
          p_36_6 <= 0;
          p_36_8 <= 0;
          p_36_9 <= 0;
          p_55 <= 1;
          p_58 <= 0;
          p_61 <= 1;
      Elsif rising_edge(Clk) Then
        If Enable = '1' Then
          p_34_8_avail := p_34_8;
          p_34_8_add := 0;   -- pl_8_2;
          p_34_9_avail := p_34_9;
          p_34_9_add := 0;   -- pl_9_2;
          p_36_4_avail := p_36_4;
          p_36_4_add := 0;   -- pl_4_3;
          p_36_5_avail := p_36_5;
          p_36_5_add := 0;   -- pl_5_3;
          p_36_6_avail := p_36_6;
          p_36_6_add := 0;   -- pl_6_3;
          p_36_8_avail := p_36_8;
          p_36_8_add := 0;   -- pl_8_3;
          p_36_9_avail := p_36_9;
          p_36_9_add := 0;   -- pl_9_3;
          p_55_avail := p_55;
          p_55_add := 0;   -- pl_32_2;
          p_58_avail := p_58;
          p_58_add := 0;   -- ppb_2;
          p_61_avail := p_61;
          p_61_add := 0;   -- ppb_3;

          out_evt_event90_td_2 <= '0';

          -- Transition 34_13 - tr_13_2
          If (p_34_8_avail >= 1) and
             (p_55_avail >= 1) and 
             (conv_integer(ini_2) = 1) -- guard expr 
          Then
              p_34_8_avail := p_34_8_avail - 1;    -- pl_8_2
              p_55_avail := p_55_avail - 1;    -- pl_32_2
              p_34_9_add := p_34_9_add + 1;   -- pl_9_2
          End If;

          -- Transition 34_25 - tr_25_2
          If (p_34_9_avail >= 1) and 
             (conv_integer(ini_2) = 1) -- guard expr 
          Then
              p_34_9_avail := p_34_9_avail - 1;    -- pl_9_2
              p_58_add := p_58_add + 1;   -- ppb_2
              out_evt_event90_td_2 <= '1';
          End If;

          -- Transition 36_10 - tr_10_3
          If (p_58_avail >= 1) and 
             (conv_integer(outi_3) = 1) -- guard expr 
          Then
              p_58_avail := p_58_avail - 1;    -- ppb_2
              p_36_4_add := p_36_4_add + 1;   -- pl_4_3
          End If;

          -- Transition 36_11 - tr_11_3
          If (p_36_4_avail >= 1) and
             (p_36_5_avail >= 1) and 
             (conv_integer(outi_3) = 1) -- guard expr 
          Then
              p_36_4_avail := p_36_4_avail - 1;    -- pl_4_3
              p_36_5_avail := p_36_5_avail - 1;    -- pl_5_3
              p_36_6_add := p_36_6_add + 1;   -- pl_6_3
          End If;

          -- Transition 36_12 - tr_12_3
          If (p_36_6_avail >= 1) and 
             (conv_integer(outi_3) = 0) -- guard expr 
          Then
              p_36_6_avail := p_36_6_avail - 1;    -- pl_6_3
              p_36_8_add := p_36_8_add + 1;   -- pl_8_3
              p_55_add := p_55_add + 1;   -- pl_32_2
          End If;

          -- Transition 36_13 - tr_13_3
          If (p_36_8_avail >= 1) and
             (p_61_avail >= 1) and 
             (conv_integer(ini_3) = 1) -- guard expr 
          Then
              p_36_8_avail := p_36_8_avail - 1;    -- pl_8_3
              p_61_avail := p_61_avail - 1;    -- ppb_3
              p_36_9_add := p_36_9_add + 1;   -- pl_9_3
          End If;

          -- Transition 36_25 - tr_25_3
          If (p_36_9_avail >= 1) and 
             (conv_integer(ini_3) = 1) -- guard expr 
          Then
              p_36_9_avail := p_36_9_avail - 1;    -- pl_9_3
              p_36_5_add := p_36_5_add + 1;   -- pl_5_3
              p_61_add := p_61_add + 1;   -- ppb_3
          End If;

          -- Transition 84 - tr_12_21
          If TRUE and
             (event_event87_td_3 = '1')
          Then
              p_34_8_add := p_34_8_add + 1;   -- pl_8_2
          End If;

          -- Calculate final place marking:
          p_34_8 <= p_34_8_avail + p_34_8_add;
          p_34_9 <= p_34_9_avail + p_34_9_add;
          p_36_4 <= p_36_4_avail + p_36_4_add;
          p_36_5 <= p_36_5_avail + p_36_5_add;
          p_36_6 <= p_36_6_avail + p_36_6_add;
          p_36_8 <= p_36_8_avail + p_36_8_add;
          p_36_9 <= p_36_9_avail + p_36_9_add;
          p_55 <= p_55_avail + p_55_add;
          p_58 <= p_58_avail + p_58_add;
          p_61 <= p_61_avail + p_61_add;

          -- Apply output events to ouput signals:

          -- Calculate transition-action-output final values:
        End If;
      End If;
    End PROCESS;


    proc_place_outputs: PROCESS( Clk, Enable ) IS
    Variable exp_res, new_value: Integer;
    Begin
      If rising_edge(Clk) Then
        If Reset='1' Then
          s_movei_3 <= '0';
          s_Bot2 <= '0';
          s_Bot3 <= '0';

        Elsif Enable='1' Then

          -- Signal movei_3 default value:
          new_value := 0;

          -- movei_3 action on place ppb_2(p_58)
          If p_58 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei_3 and check result range:
          If new_value < 0 Then s_movei_3 <= '0';
            Elsif new_value > 1 Then s_movei_3 <= '1';
            Else s_movei_3 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot2 default value:
          new_value := 0;

          -- Bot2 action on place pl_8_2(p_34_8)
          If p_34_8 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot2 and check result range:
          If new_value < 0 Then s_Bot2 <= '0';
            Elsif new_value > 1 Then s_Bot2 <= '1';
            Else s_Bot2 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot3 default value:
          new_value := 0;

          -- Bot3 action on place pl_6_3(p_36_6)
          If p_36_6 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Bot3 action on place pl_8_3(p_36_8)
          If p_36_8 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot3 and check result range:
          If new_value < 0 Then s_Bot3 <= '0';
            Elsif new_value > 1 Then s_Bot3 <= '1';
            Else s_Bot3 <= conv_std_logic_vector(new_value,1)(0);
          End If;

        End If;
      End If;
    End PROCESS;

    movei_3 <= s_movei_3;
    Bot2 <= s_Bot2;
    Bot3 <= s_Bot3;

End Structural;
