-- Net CSR___Lab_3___Part1 - IOPT
-- Automatic code generated by IOPT2VHDL XSLT transformation.
-- by GRES Research Group - 2014 


Library IEEE;
Use IEEE.STD_LOGIC_1164.ALL;
Use IEEE.STD_LOGIC_ARITH.ALL;
Use IEEE.STD_LOGIC_UNSIGNED.ALL;


Entity CSR___Lab_3___Part1 IS
Port(
    Clk : IN STD_LOGIC;
    outi : IN STD_LOGIC;
    ini : IN STD_LOGIC;
    outi_2 : IN STD_LOGIC;
    ini_2 : IN STD_LOGIC;
    outi_3 : IN STD_LOGIC;
    ini_3 : IN STD_LOGIC;
    in1 : IN STD_LOGIC;
    movei : OUT STD_LOGIC;
    movei_2 : OUT STD_LOGIC;
    movei_3 : OUT STD_LOGIC;
    Bot1 : OUT STD_LOGIC;
    Bot2 : OUT STD_LOGIC;
    Bot3 : OUT STD_LOGIC;
    Enable : IN STD_LOGIC;
    Reset : IN STD_LOGIC
);
End CSR___Lab_3___Part1;

Architecture Structural OF CSR___Lab_3___Part1 IS

    Signal p_4: INTEGER RANGE 0 TO 3 := 0;
    Signal p_5: INTEGER RANGE 0 TO 3 := 1;
    Signal p_6: INTEGER RANGE 0 TO 3 := 0;
    Signal p_8: INTEGER RANGE 0 TO 3 := 0;
    Signal p_9: INTEGER RANGE 0 TO 3 := 0;
    Signal p_34_4: INTEGER RANGE 0 TO 3 := 0;
    Signal p_34_5: INTEGER RANGE 0 TO 3 := 1;
    Signal p_34_6: INTEGER RANGE 0 TO 3 := 0;
    Signal p_34_8: INTEGER RANGE 0 TO 3 := 0;
    Signal p_34_9: INTEGER RANGE 0 TO 3 := 0;
    Signal p_36_4: INTEGER RANGE 0 TO 3 := 0;
    Signal p_36_5: INTEGER RANGE 0 TO 3 := 1;
    Signal p_36_6: INTEGER RANGE 0 TO 3 := 0;
    Signal p_36_8: INTEGER RANGE 0 TO 3 := 0;
    Signal p_36_9: INTEGER RANGE 0 TO 3 := 0;
    Signal p_43: INTEGER RANGE 0 TO 3 := 1;
    Signal p_46: INTEGER RANGE 0 TO 3 := 0;
    Signal p_49: INTEGER RANGE 0 TO 3 := 0;
    Signal p_52: INTEGER RANGE 0 TO 3 := 1;
    Signal p_55: INTEGER RANGE 0 TO 3 := 1;
    Signal p_58: INTEGER RANGE 0 TO 3 := 0;
    Signal p_61: INTEGER RANGE 0 TO 3 := 1;


    Signal s_movei : STD_LOGIC := '0';
    Signal s_movei_2 : STD_LOGIC := '0';
    Signal s_movei_3 : STD_LOGIC := '0';
    Signal s_Bot1 : STD_LOGIC := '0';
    Signal s_Bot2 : STD_LOGIC := '0';
    Signal s_Bot3 : STD_LOGIC := '0';

    -- Array implementation:

Begin
    -- Selected array items:

    proc_in_events: PROCESS( Clk, Enable ) IS
    Begin
      If falling_edge(Clk) Then
        If Reset = '0' AND Enable = '1' Then
        End If;
      End If;
    End PROCESS;


    proc_transitions: PROCESS( Clk, Enable, Reset ) IS
      Variable p_4_add, p_4_avail : INTEGER RANGE 0 to 3;
      Variable p_5_add, p_5_avail : INTEGER RANGE 0 to 3;
      Variable p_6_add, p_6_avail : INTEGER RANGE 0 to 3;
      Variable p_8_add, p_8_avail : INTEGER RANGE 0 to 3;
      Variable p_9_add, p_9_avail : INTEGER RANGE 0 to 3;
      Variable p_34_4_add, p_34_4_avail : INTEGER RANGE 0 to 3;
      Variable p_34_5_add, p_34_5_avail : INTEGER RANGE 0 to 3;
      Variable p_34_6_add, p_34_6_avail : INTEGER RANGE 0 to 3;
      Variable p_34_8_add, p_34_8_avail : INTEGER RANGE 0 to 3;
      Variable p_34_9_add, p_34_9_avail : INTEGER RANGE 0 to 3;
      Variable p_36_4_add, p_36_4_avail : INTEGER RANGE 0 to 3;
      Variable p_36_5_add, p_36_5_avail : INTEGER RANGE 0 to 3;
      Variable p_36_6_add, p_36_6_avail : INTEGER RANGE 0 to 3;
      Variable p_36_8_add, p_36_8_avail : INTEGER RANGE 0 to 3;
      Variable p_36_9_add, p_36_9_avail : INTEGER RANGE 0 to 3;
      Variable p_43_add, p_43_avail : INTEGER RANGE 0 to 3;
      Variable p_46_add, p_46_avail : INTEGER RANGE 0 to 3;
      Variable p_49_add, p_49_avail : INTEGER RANGE 0 to 3;
      Variable p_52_add, p_52_avail : INTEGER RANGE 0 to 3;
      Variable p_55_add, p_55_avail : INTEGER RANGE 0 to 3;
      Variable p_58_add, p_58_avail : INTEGER RANGE 0 to 3;
      Variable p_61_add, p_61_avail : INTEGER RANGE 0 to 3;
    Begin
      If Reset = '1' Then
          p_4 <= 0;
          p_5 <= 1;
          p_6 <= 0;
          p_8 <= 0;
          p_9 <= 0;
          p_34_4 <= 0;
          p_34_5 <= 1;
          p_34_6 <= 0;
          p_34_8 <= 0;
          p_34_9 <= 0;
          p_36_4 <= 0;
          p_36_5 <= 1;
          p_36_6 <= 0;
          p_36_8 <= 0;
          p_36_9 <= 0;
          p_43 <= 1;
          p_46 <= 0;
          p_49 <= 0;
          p_52 <= 1;
          p_55 <= 1;
          p_58 <= 0;
          p_61 <= 1;
      Elsif rising_edge(Clk) Then
        If Enable = '1' Then
          p_4_avail := p_4;
          p_4_add := 0;   -- pl_4;
          p_5_avail := p_5;
          p_5_add := 0;   -- pl_5;
          p_6_avail := p_6;
          p_6_add := 0;   -- pl_6;
          p_8_avail := p_8;
          p_8_add := 0;   -- pl_8;
          p_9_avail := p_9;
          p_9_add := 0;   -- pl_9;
          p_34_4_avail := p_34_4;
          p_34_4_add := 0;   -- pl_4_2;
          p_34_5_avail := p_34_5;
          p_34_5_add := 0;   -- pl_5_2;
          p_34_6_avail := p_34_6;
          p_34_6_add := 0;   -- pl_6_2;
          p_34_8_avail := p_34_8;
          p_34_8_add := 0;   -- pl_8_2;
          p_34_9_avail := p_34_9;
          p_34_9_add := 0;   -- pl_9_2;
          p_36_4_avail := p_36_4;
          p_36_4_add := 0;   -- pl_4_3;
          p_36_5_avail := p_36_5;
          p_36_5_add := 0;   -- pl_5_3;
          p_36_6_avail := p_36_6;
          p_36_6_add := 0;   -- pl_6_3;
          p_36_8_avail := p_36_8;
          p_36_8_add := 0;   -- pl_8_3;
          p_36_9_avail := p_36_9;
          p_36_9_add := 0;   -- pl_9_3;
          p_43_avail := p_43;
          p_43_add := 0;   -- pl_37;
          p_46_avail := p_46;
          p_46_add := 0;   -- pl_38;
          p_49_avail := p_49;
          p_49_add := 0;   -- ppb;
          p_52_avail := p_52;
          p_52_add := 0;   -- pl_32;
          p_55_avail := p_55;
          p_55_add := 0;   -- pl_32_2;
          p_58_avail := p_58;
          p_58_add := 0;   -- ppb_2;
          p_61_avail := p_61;
          p_61_add := 0;   -- ppb_3;


          -- Transition 10 - tr_10
          If (p_46_avail >= 1) and 
             (conv_integer(outi) = 1) -- guard expr 
          Then
              p_46_avail := p_46_avail - 1;    -- pl_38
              p_4_add := p_4_add + 1;   -- pl_4
          End If;

          -- Transition 11 - tr_11
          If (p_4_avail >= 1) and
             (p_5_avail >= 1) and 
             (conv_integer(outi) = 1) -- guard expr 
          Then
              p_4_avail := p_4_avail - 1;    -- pl_4
              p_5_avail := p_5_avail - 1;    -- pl_5
              p_6_add := p_6_add + 1;   -- pl_6
          End If;

          -- Transition 12 - tr_12
          If (p_6_avail >= 1) and 
             (conv_integer(outi) = 0) -- guard expr 
          Then
              p_6_avail := p_6_avail - 1;    -- pl_6
              p_8_add := p_8_add + 1;   -- pl_8
              p_43_add := p_43_add + 1;   -- pl_37
          End If;

          -- Transition 13 - tr_13
          If (p_8_avail >= 1) and
             (p_52_avail >= 1) and 
             (conv_integer(ini) = 1) -- guard expr 
          Then
              p_8_avail := p_8_avail - 1;    -- pl_8
              p_52_avail := p_52_avail - 1;    -- pl_32
              p_9_add := p_9_add + 1;   -- pl_9
          End If;

          -- Transition 25 - tr_25
          If (p_9_avail >= 1) and 
             (conv_integer(ini) = 1) -- guard expr 
          Then
              p_9_avail := p_9_avail - 1;    -- pl_9
              p_5_add := p_5_add + 1;   -- pl_5
              p_49_add := p_49_add + 1;   -- ppb
          End If;

          -- Transition 34_10 - tr_10_2
          If (p_49_avail >= 1) and 
             (conv_integer(outi_2) = 1) -- guard expr 
          Then
              p_49_avail := p_49_avail - 1;    -- ppb
              p_34_4_add := p_34_4_add + 1;   -- pl_4_2
          End If;

          -- Transition 34_11 - tr_11_2
          If (p_34_4_avail >= 1) and
             (p_34_5_avail >= 1) and 
             (conv_integer(outi_2) = 1) -- guard expr 
          Then
              p_34_4_avail := p_34_4_avail - 1;    -- pl_4_2
              p_34_5_avail := p_34_5_avail - 1;    -- pl_5_2
              p_34_6_add := p_34_6_add + 1;   -- pl_6_2
          End If;

          -- Transition 34_12 - tr_12_2
          If (p_34_6_avail >= 1) and 
             (conv_integer(outi_2) = 0) -- guard expr 
          Then
              p_34_6_avail := p_34_6_avail - 1;    -- pl_6_2
              p_34_8_add := p_34_8_add + 1;   -- pl_8_2
              p_52_add := p_52_add + 1;   -- pl_32
          End If;

          -- Transition 34_13 - tr_13_2
          If (p_34_8_avail >= 1) and
             (p_55_avail >= 1) and 
             (conv_integer(ini_2) = 1) -- guard expr 
          Then
              p_34_8_avail := p_34_8_avail - 1;    -- pl_8_2
              p_55_avail := p_55_avail - 1;    -- pl_32_2
              p_34_9_add := p_34_9_add + 1;   -- pl_9_2
          End If;

          -- Transition 34_25 - tr_25_2
          If (p_34_9_avail >= 1) and 
             (conv_integer(ini_2) = 1) -- guard expr 
          Then
              p_34_9_avail := p_34_9_avail - 1;    -- pl_9_2
              p_34_5_add := p_34_5_add + 1;   -- pl_5_2
              p_58_add := p_58_add + 1;   -- ppb_2
          End If;

          -- Transition 36_10 - tr_10_3
          If (p_58_avail >= 1) and 
             (conv_integer(outi_3) = 1) -- guard expr 
          Then
              p_58_avail := p_58_avail - 1;    -- ppb_2
              p_36_4_add := p_36_4_add + 1;   -- pl_4_3
          End If;

          -- Transition 36_11 - tr_11_3
          If (p_36_4_avail >= 1) and
             (p_36_5_avail >= 1) and 
             (conv_integer(outi_3) = 1) -- guard expr 
          Then
              p_36_4_avail := p_36_4_avail - 1;    -- pl_4_3
              p_36_5_avail := p_36_5_avail - 1;    -- pl_5_3
              p_36_6_add := p_36_6_add + 1;   -- pl_6_3
          End If;

          -- Transition 36_12 - tr_12_3
          If (p_36_6_avail >= 1) and 
             (conv_integer(outi_3) = 0) -- guard expr 
          Then
              p_36_6_avail := p_36_6_avail - 1;    -- pl_6_3
              p_36_8_add := p_36_8_add + 1;   -- pl_8_3
              p_55_add := p_55_add + 1;   -- pl_32_2
          End If;

          -- Transition 36_13 - tr_13_3
          If (p_36_8_avail >= 1) and
             (p_61_avail >= 1) and 
             (conv_integer(ini_3) = 1) -- guard expr 
          Then
              p_36_8_avail := p_36_8_avail - 1;    -- pl_8_3
              p_61_avail := p_61_avail - 1;    -- ppb_3
              p_36_9_add := p_36_9_add + 1;   -- pl_9_3
          End If;

          -- Transition 36_25 - tr_25_3
          If (p_36_9_avail >= 1) and 
             (conv_integer(ini_3) = 1) -- guard expr 
          Then
              p_36_9_avail := p_36_9_avail - 1;    -- pl_9_3
              p_36_5_add := p_36_5_add + 1;   -- pl_5_3
              p_61_add := p_61_add + 1;   -- ppb_3
          End If;

          -- Transition 39 - tr_39
          If (p_43_avail >= 1) and 
             (conv_integer(in1) = 1) -- guard expr 
          Then
              p_43_avail := p_43_avail - 1;    -- pl_37
              p_46_add := p_46_add + 1;   -- pl_38
          End If;

          -- Calculate final place marking:
          p_4 <= p_4_avail + p_4_add;
          p_5 <= p_5_avail + p_5_add;
          p_6 <= p_6_avail + p_6_add;
          p_8 <= p_8_avail + p_8_add;
          p_9 <= p_9_avail + p_9_add;
          p_34_4 <= p_34_4_avail + p_34_4_add;
          p_34_5 <= p_34_5_avail + p_34_5_add;
          p_34_6 <= p_34_6_avail + p_34_6_add;
          p_34_8 <= p_34_8_avail + p_34_8_add;
          p_34_9 <= p_34_9_avail + p_34_9_add;
          p_36_4 <= p_36_4_avail + p_36_4_add;
          p_36_5 <= p_36_5_avail + p_36_5_add;
          p_36_6 <= p_36_6_avail + p_36_6_add;
          p_36_8 <= p_36_8_avail + p_36_8_add;
          p_36_9 <= p_36_9_avail + p_36_9_add;
          p_43 <= p_43_avail + p_43_add;
          p_46 <= p_46_avail + p_46_add;
          p_49 <= p_49_avail + p_49_add;
          p_52 <= p_52_avail + p_52_add;
          p_55 <= p_55_avail + p_55_add;
          p_58 <= p_58_avail + p_58_add;
          p_61 <= p_61_avail + p_61_add;

          -- Apply output events to ouput signals:

          -- Calculate transition-action-output final values:
        End If;
      End If;
    End PROCESS;


    proc_place_outputs: PROCESS( Clk, Enable ) IS
    Variable exp_res, new_value: Integer;
    Begin
      If rising_edge(Clk) Then
        If Reset='1' Then
          s_movei <= '0';
          s_movei_2 <= '0';
          s_movei_3 <= '0';
          s_Bot1 <= '0';
          s_Bot2 <= '0';
          s_Bot3 <= '0';

        Elsif Enable='1' Then

          -- Signal movei default value:
          new_value := 0;

          -- movei action on place pl_38(p_46)
          If p_46 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei and check result range:
          If new_value < 0 Then s_movei <= '0';
            Elsif new_value > 1 Then s_movei <= '1';
            Else s_movei <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal movei_2 default value:
          new_value := 0;

          -- movei_2 action on place ppb(p_49)
          If p_49 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei_2 and check result range:
          If new_value < 0 Then s_movei_2 <= '0';
            Elsif new_value > 1 Then s_movei_2 <= '1';
            Else s_movei_2 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal movei_3 default value:
          new_value := 0;

          -- movei_3 action on place ppb_2(p_58)
          If p_58 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei_3 and check result range:
          If new_value < 0 Then s_movei_3 <= '0';
            Elsif new_value > 1 Then s_movei_3 <= '1';
            Else s_movei_3 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot1 default value:
          new_value := 0;

          -- Bot1 action on place pl_6(p_6)
          If p_6 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Bot1 action on place pl_8(p_8)
          If p_8 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot1 and check result range:
          If new_value < 0 Then s_Bot1 <= '0';
            Elsif new_value > 1 Then s_Bot1 <= '1';
            Else s_Bot1 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot2 default value:
          new_value := 0;

          -- Bot2 action on place pl_6_2(p_34_6)
          If p_34_6 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Bot2 action on place pl_8_2(p_34_8)
          If p_34_8 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot2 and check result range:
          If new_value < 0 Then s_Bot2 <= '0';
            Elsif new_value > 1 Then s_Bot2 <= '1';
            Else s_Bot2 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot3 default value:
          new_value := 0;

          -- Bot3 action on place pl_6_3(p_36_6)
          If p_36_6 > 0 Then
            exp_res := 1;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Bot3 action on place pl_8_3(p_36_8)
          If p_36_8 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot3 and check result range:
          If new_value < 0 Then s_Bot3 <= '0';
            Elsif new_value > 1 Then s_Bot3 <= '1';
            Else s_Bot3 <= conv_std_logic_vector(new_value,1)(0);
          End If;

        End If;
      End If;
    End PROCESS;

    movei <= s_movei;
    movei_2 <= s_movei_2;
    movei_3 <= s_movei_3;
    Bot1 <= s_Bot1;
    Bot2 <= s_Bot2;
    Bot3 <= s_Bot3;

End Structural;
