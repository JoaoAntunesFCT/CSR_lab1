-- Net CSR___Lab3___Part4 - IOPT
-- Automatic code generated by IOPT2VHDL XSLT transformation.
-- by GRES Research Group - 2014 


Library IEEE;
Use IEEE.STD_LOGIC_1164.ALL;
Use IEEE.STD_LOGIC_ARITH.ALL;
Use IEEE.STD_LOGIC_UNSIGNED.ALL;


Entity CSR___Lab3___Part4 IS
Port(
    Clk : IN STD_LOGIC;
    ini : IN STD_LOGIC;
    outi : IN STD_LOGIC;
    ini_2 : IN STD_LOGIC;
    outi_2 : IN STD_LOGIC;
    ini_3 : IN STD_LOGIC;
    outi_3 : IN STD_LOGIC;
    in1 : IN STD_LOGIC;
    Bot1_i : IN STD_LOGIC;
    Bot2_i : IN STD_LOGIC;
    Bot3_i : IN STD_LOGIC;
    movei_i : IN STD_LOGIC;
    movei_2_i : IN STD_LOGIC;
    movei_3_i : IN STD_LOGIC;
    Bot1 : OUT STD_LOGIC;
    Bot2 : OUT STD_LOGIC;
    Bot3 : OUT STD_LOGIC;
    movei : OUT STD_LOGIC;
    movei_2 : OUT STD_LOGIC;
    movei_3 : OUT STD_LOGIC;
    in1_o : OUT STD_LOGIC;
    ini_o : OUT STD_LOGIC;
    outi_o : OUT STD_LOGIC;
    ini_2_o : OUT STD_LOGIC;
    outi_2_o : OUT STD_LOGIC;
    ini_3_o : OUT STD_LOGIC;
    outi_3_o : OUT STD_LOGIC;
    Enable : IN STD_LOGIC;
    Reset : IN STD_LOGIC
);
End CSR___Lab3___Part4;

Architecture Structural OF CSR___Lab3___Part4 IS

    Signal p_2: INTEGER RANGE 0 TO 3 := 1;
    Signal p_5: INTEGER RANGE 0 TO 3 := 0;
    Signal p_10: INTEGER RANGE 0 TO 3 := 1;
    Signal p_13: INTEGER RANGE 0 TO 3 := 0;
    Signal p_18: INTEGER RANGE 0 TO 3 := 1;
    Signal p_21: INTEGER RANGE 0 TO 3 := 0;
    Signal p_26: INTEGER RANGE 0 TO 3 := 1;
    Signal p_29: INTEGER RANGE 0 TO 3 := 0;
    Signal p_34: INTEGER RANGE 0 TO 3 := 1;
    Signal p_37: INTEGER RANGE 0 TO 3 := 0;
    Signal p_42: INTEGER RANGE 0 TO 3 := 1;
    Signal p_45: INTEGER RANGE 0 TO 3 := 0;
    Signal p_50: INTEGER RANGE 0 TO 3 := 1;
    Signal p_53: INTEGER RANGE 0 TO 3 := 0;
    Signal p_58: INTEGER RANGE 0 TO 3 := 1;
    Signal p_61: INTEGER RANGE 0 TO 3 := 0;
    Signal p_66: INTEGER RANGE 0 TO 3 := 1;
    Signal p_69: INTEGER RANGE 0 TO 3 := 0;
    Signal p_74: INTEGER RANGE 0 TO 3 := 1;
    Signal p_77: INTEGER RANGE 0 TO 3 := 0;
    Signal p_82: INTEGER RANGE 0 TO 3 := 1;
    Signal p_85: INTEGER RANGE 0 TO 3 := 0;
    Signal p_90: INTEGER RANGE 0 TO 3 := 1;
    Signal p_93: INTEGER RANGE 0 TO 3 := 0;
    Signal p_98: INTEGER RANGE 0 TO 3 := 1;
    Signal p_101: INTEGER RANGE 0 TO 3 := 0;


    Signal s_Bot1 : STD_LOGIC := '0';
    Signal s_Bot2 : STD_LOGIC := '0';
    Signal s_Bot3 : STD_LOGIC := '0';
    Signal s_movei : STD_LOGIC := '0';
    Signal s_movei_2 : STD_LOGIC := '0';
    Signal s_movei_3 : STD_LOGIC := '0';
    Signal s_in1_o : STD_LOGIC := '0';
    Signal s_ini_o : STD_LOGIC := '0';
    Signal s_outi_o : STD_LOGIC := '0';
    Signal s_ini_2_o : STD_LOGIC := '0';
    Signal s_outi_2_o : STD_LOGIC := '0';
    Signal s_ini_3_o : STD_LOGIC := '0';
    Signal s_outi_3_o : STD_LOGIC := '0';

    -- Array implementation:

Begin
    -- Selected array items:

    proc_in_events: PROCESS( Clk, Enable ) IS
    Begin
      If falling_edge(Clk) Then
        If Reset = '0' AND Enable = '1' Then
        End If;
      End If;
    End PROCESS;


    proc_transitions: PROCESS( Clk, Enable, Reset ) IS
      Variable p_2_add, p_2_avail : INTEGER RANGE 0 to 3;
      Variable p_5_add, p_5_avail : INTEGER RANGE 0 to 3;
      Variable p_10_add, p_10_avail : INTEGER RANGE 0 to 3;
      Variable p_13_add, p_13_avail : INTEGER RANGE 0 to 3;
      Variable p_18_add, p_18_avail : INTEGER RANGE 0 to 3;
      Variable p_21_add, p_21_avail : INTEGER RANGE 0 to 3;
      Variable p_26_add, p_26_avail : INTEGER RANGE 0 to 3;
      Variable p_29_add, p_29_avail : INTEGER RANGE 0 to 3;
      Variable p_34_add, p_34_avail : INTEGER RANGE 0 to 3;
      Variable p_37_add, p_37_avail : INTEGER RANGE 0 to 3;
      Variable p_42_add, p_42_avail : INTEGER RANGE 0 to 3;
      Variable p_45_add, p_45_avail : INTEGER RANGE 0 to 3;
      Variable p_50_add, p_50_avail : INTEGER RANGE 0 to 3;
      Variable p_53_add, p_53_avail : INTEGER RANGE 0 to 3;
      Variable p_58_add, p_58_avail : INTEGER RANGE 0 to 3;
      Variable p_61_add, p_61_avail : INTEGER RANGE 0 to 3;
      Variable p_66_add, p_66_avail : INTEGER RANGE 0 to 3;
      Variable p_69_add, p_69_avail : INTEGER RANGE 0 to 3;
      Variable p_74_add, p_74_avail : INTEGER RANGE 0 to 3;
      Variable p_77_add, p_77_avail : INTEGER RANGE 0 to 3;
      Variable p_82_add, p_82_avail : INTEGER RANGE 0 to 3;
      Variable p_85_add, p_85_avail : INTEGER RANGE 0 to 3;
      Variable p_90_add, p_90_avail : INTEGER RANGE 0 to 3;
      Variable p_93_add, p_93_avail : INTEGER RANGE 0 to 3;
      Variable p_98_add, p_98_avail : INTEGER RANGE 0 to 3;
      Variable p_101_add, p_101_avail : INTEGER RANGE 0 to 3;
    Begin
      If Reset = '1' Then
          p_2 <= 1;
          p_5 <= 0;
          p_10 <= 1;
          p_13 <= 0;
          p_18 <= 1;
          p_21 <= 0;
          p_26 <= 1;
          p_29 <= 0;
          p_34 <= 1;
          p_37 <= 0;
          p_42 <= 1;
          p_45 <= 0;
          p_50 <= 1;
          p_53 <= 0;
          p_58 <= 1;
          p_61 <= 0;
          p_66 <= 1;
          p_69 <= 0;
          p_74 <= 1;
          p_77 <= 0;
          p_82 <= 1;
          p_85 <= 0;
          p_90 <= 1;
          p_93 <= 0;
          p_98 <= 1;
          p_101 <= 0;
      Elsif rising_edge(Clk) Then
        If Enable = '1' Then
          p_2_avail := p_2;
          p_2_add := 0;   -- pl_2;
          p_5_avail := p_5;
          p_5_add := 0;   -- pl_5;
          p_10_avail := p_10;
          p_10_add := 0;   -- pl_2_2;
          p_13_avail := p_13;
          p_13_add := 0;   -- pl_5_2;
          p_18_avail := p_18;
          p_18_add := 0;   -- pl_2_3;
          p_21_avail := p_21;
          p_21_add := 0;   -- pl_5_3;
          p_26_avail := p_26;
          p_26_add := 0;   -- pl_2_4;
          p_29_avail := p_29;
          p_29_add := 0;   -- pl_5_4;
          p_34_avail := p_34;
          p_34_add := 0;   -- pl_2_5;
          p_37_avail := p_37;
          p_37_add := 0;   -- pl_5_5;
          p_42_avail := p_42;
          p_42_add := 0;   -- pl_2_6;
          p_45_avail := p_45;
          p_45_add := 0;   -- pl_5_6;
          p_50_avail := p_50;
          p_50_add := 0;   -- pl_2_7;
          p_53_avail := p_53;
          p_53_add := 0;   -- pl_5_7;
          p_58_avail := p_58;
          p_58_add := 0;   -- pl_2_8;
          p_61_avail := p_61;
          p_61_add := 0;   -- pl_5_8;
          p_66_avail := p_66;
          p_66_add := 0;   -- pl_2_9;
          p_69_avail := p_69;
          p_69_add := 0;   -- pl_5_9;
          p_74_avail := p_74;
          p_74_add := 0;   -- pl_2_10;
          p_77_avail := p_77;
          p_77_add := 0;   -- pl_5_10;
          p_82_avail := p_82;
          p_82_add := 0;   -- pl_2_11;
          p_85_avail := p_85;
          p_85_add := 0;   -- pl_5_11;
          p_90_avail := p_90;
          p_90_add := 0;   -- pl_2_12;
          p_93_avail := p_93;
          p_93_add := 0;   -- pl_5_12;
          p_98_avail := p_98;
          p_98_add := 0;   -- pl_2_13;
          p_101_avail := p_101;
          p_101_add := 0;   -- pl_5_13;


          -- Transition 3 - tr_3
          If (p_2_avail >= 1) and 
             (conv_integer(Bot1_i) = 1) -- guard expr 
          Then
              p_2_avail := p_2_avail - 1;    -- pl_2
              p_5_add := p_5_add + 1;   -- pl_5
          End If;

          -- Transition 4 - tr_4
          If (p_5_avail >= 1) and 
             (conv_integer(Bot1_i) = 0) -- guard expr 
          Then
              p_5_avail := p_5_avail - 1;    -- pl_5
              p_2_add := p_2_add + 1;   -- pl_2
          End If;

          -- Transition 11 - tr_3_2
          If (p_10_avail >= 1) and 
             (conv_integer(Bot2_i) = 1) -- guard expr 
          Then
              p_10_avail := p_10_avail - 1;    -- pl_2_2
              p_13_add := p_13_add + 1;   -- pl_5_2
          End If;

          -- Transition 12 - tr_4_2
          If (p_13_avail >= 1) and 
             (conv_integer(Bot2_i) = 0) -- guard expr 
          Then
              p_13_avail := p_13_avail - 1;    -- pl_5_2
              p_10_add := p_10_add + 1;   -- pl_2_2
          End If;

          -- Transition 19 - tr_3_3
          If (p_18_avail >= 1) and 
             (conv_integer(Bot3_i) = 1) -- guard expr 
          Then
              p_18_avail := p_18_avail - 1;    -- pl_2_3
              p_21_add := p_21_add + 1;   -- pl_5_3
          End If;

          -- Transition 20 - tr_4_3
          If (p_21_avail >= 1) and 
             (conv_integer(Bot3_i) = 0) -- guard expr 
          Then
              p_21_avail := p_21_avail - 1;    -- pl_5_3
              p_18_add := p_18_add + 1;   -- pl_2_3
          End If;

          -- Transition 27 - tr_3_4
          If (p_26_avail >= 1) and 
             (conv_integer(movei_i) = 1) -- guard expr 
          Then
              p_26_avail := p_26_avail - 1;    -- pl_2_4
              p_29_add := p_29_add + 1;   -- pl_5_4
          End If;

          -- Transition 28 - tr_4_4
          If (p_29_avail >= 1) and 
             (conv_integer(movei_i) = 0) -- guard expr 
          Then
              p_29_avail := p_29_avail - 1;    -- pl_5_4
              p_26_add := p_26_add + 1;   -- pl_2_4
          End If;

          -- Transition 35 - tr_3_5
          If (p_34_avail >= 1) and 
             (conv_integer(movei_2_i) = 1) -- guard expr 
          Then
              p_34_avail := p_34_avail - 1;    -- pl_2_5
              p_37_add := p_37_add + 1;   -- pl_5_5
          End If;

          -- Transition 36 - tr_4_5
          If (p_37_avail >= 1) and 
             (conv_integer(movei_2_i) = 0) -- guard expr 
          Then
              p_37_avail := p_37_avail - 1;    -- pl_5_5
              p_34_add := p_34_add + 1;   -- pl_2_5
          End If;

          -- Transition 43 - tr_3_6
          If (p_42_avail >= 1) and 
             (conv_integer(movei_3_i) = 1) -- guard expr 
          Then
              p_42_avail := p_42_avail - 1;    -- pl_2_6
              p_45_add := p_45_add + 1;   -- pl_5_6
          End If;

          -- Transition 44 - tr_4_6
          If (p_45_avail >= 1) and 
             (conv_integer(movei_3_i) = 0) -- guard expr 
          Then
              p_45_avail := p_45_avail - 1;    -- pl_5_6
              p_42_add := p_42_add + 1;   -- pl_2_6
          End If;

          -- Transition 51 - tr_3_7
          If (p_50_avail >= 1) and 
             (conv_integer(in1) = 1) -- guard expr 
          Then
              p_50_avail := p_50_avail - 1;    -- pl_2_7
              p_53_add := p_53_add + 1;   -- pl_5_7
          End If;

          -- Transition 52 - tr_4_7
          If (p_53_avail >= 1) and 
             (conv_integer(in1) = 0) -- guard expr 
          Then
              p_53_avail := p_53_avail - 1;    -- pl_5_7
              p_50_add := p_50_add + 1;   -- pl_2_7
          End If;

          -- Transition 59 - tr_3_8
          If (p_58_avail >= 1) and 
             (conv_integer(ini) = 1) -- guard expr 
          Then
              p_58_avail := p_58_avail - 1;    -- pl_2_8
              p_61_add := p_61_add + 1;   -- pl_5_8
          End If;

          -- Transition 60 - tr_4_8
          If (p_61_avail >= 1) and 
             (conv_integer(ini) = 0) -- guard expr 
          Then
              p_61_avail := p_61_avail - 1;    -- pl_5_8
              p_58_add := p_58_add + 1;   -- pl_2_8
          End If;

          -- Transition 67 - tr_3_9
          If (p_66_avail >= 1) and 
             (conv_integer(outi) = 1) -- guard expr 
          Then
              p_66_avail := p_66_avail - 1;    -- pl_2_9
              p_69_add := p_69_add + 1;   -- pl_5_9
          End If;

          -- Transition 68 - tr_4_9
          If (p_69_avail >= 1) and 
             (conv_integer(outi) = 0) -- guard expr 
          Then
              p_69_avail := p_69_avail - 1;    -- pl_5_9
              p_66_add := p_66_add + 1;   -- pl_2_9
          End If;

          -- Transition 75 - tr_3_10
          If (p_74_avail >= 1) and 
             (conv_integer(ini_2) = 1) -- guard expr 
          Then
              p_74_avail := p_74_avail - 1;    -- pl_2_10
              p_77_add := p_77_add + 1;   -- pl_5_10
          End If;

          -- Transition 76 - tr_4_10
          If (p_77_avail >= 1) and 
             (conv_integer(ini_2) = 0) -- guard expr 
          Then
              p_77_avail := p_77_avail - 1;    -- pl_5_10
              p_74_add := p_74_add + 1;   -- pl_2_10
          End If;

          -- Transition 83 - tr_3_11
          If (p_82_avail >= 1) and 
             (conv_integer(outi_2) = 1) -- guard expr 
          Then
              p_82_avail := p_82_avail - 1;    -- pl_2_11
              p_85_add := p_85_add + 1;   -- pl_5_11
          End If;

          -- Transition 84 - tr_4_11
          If (p_85_avail >= 1) and 
             (conv_integer(outi_2) = 0) -- guard expr 
          Then
              p_85_avail := p_85_avail - 1;    -- pl_5_11
              p_82_add := p_82_add + 1;   -- pl_2_11
          End If;

          -- Transition 91 - tr_3_12
          If (p_90_avail >= 1) and 
             (conv_integer(ini_3) = 1) -- guard expr 
          Then
              p_90_avail := p_90_avail - 1;    -- pl_2_12
              p_93_add := p_93_add + 1;   -- pl_5_12
          End If;

          -- Transition 92 - tr_4_12
          If (p_93_avail >= 1) and 
             (conv_integer(ini_3) = 0) -- guard expr 
          Then
              p_93_avail := p_93_avail - 1;    -- pl_5_12
              p_90_add := p_90_add + 1;   -- pl_2_12
          End If;

          -- Transition 99 - tr_3_13
          If (p_98_avail >= 1) and 
             (conv_integer(outi_3) = 1) -- guard expr 
          Then
              p_98_avail := p_98_avail - 1;    -- pl_2_13
              p_101_add := p_101_add + 1;   -- pl_5_13
          End If;

          -- Transition 100 - tr_4_13
          If (p_101_avail >= 1) and 
             (conv_integer(outi_3) = 0) -- guard expr 
          Then
              p_101_avail := p_101_avail - 1;    -- pl_5_13
              p_98_add := p_98_add + 1;   -- pl_2_13
          End If;

          -- Calculate final place marking:
          p_2 <= p_2_avail + p_2_add;
          p_5 <= p_5_avail + p_5_add;
          p_10 <= p_10_avail + p_10_add;
          p_13 <= p_13_avail + p_13_add;
          p_18 <= p_18_avail + p_18_add;
          p_21 <= p_21_avail + p_21_add;
          p_26 <= p_26_avail + p_26_add;
          p_29 <= p_29_avail + p_29_add;
          p_34 <= p_34_avail + p_34_add;
          p_37 <= p_37_avail + p_37_add;
          p_42 <= p_42_avail + p_42_add;
          p_45 <= p_45_avail + p_45_add;
          p_50 <= p_50_avail + p_50_add;
          p_53 <= p_53_avail + p_53_add;
          p_58 <= p_58_avail + p_58_add;
          p_61 <= p_61_avail + p_61_add;
          p_66 <= p_66_avail + p_66_add;
          p_69 <= p_69_avail + p_69_add;
          p_74 <= p_74_avail + p_74_add;
          p_77 <= p_77_avail + p_77_add;
          p_82 <= p_82_avail + p_82_add;
          p_85 <= p_85_avail + p_85_add;
          p_90 <= p_90_avail + p_90_add;
          p_93 <= p_93_avail + p_93_add;
          p_98 <= p_98_avail + p_98_add;
          p_101 <= p_101_avail + p_101_add;

          -- Apply output events to ouput signals:

          -- Calculate transition-action-output final values:
        End If;
      End If;
    End PROCESS;


    proc_place_outputs: PROCESS( Clk, Enable ) IS
    Variable exp_res, new_value: Integer;
    Begin
      If rising_edge(Clk) Then
        If Reset='1' Then
          s_Bot1 <= '0';
          s_Bot2 <= '0';
          s_Bot3 <= '0';
          s_movei <= '0';
          s_movei_2 <= '0';
          s_movei_3 <= '0';
          s_in1_o <= '0';
          s_ini_o <= '0';
          s_outi_o <= '0';
          s_ini_2_o <= '0';
          s_outi_2_o <= '0';
          s_ini_3_o <= '0';
          s_outi_3_o <= '0';

        Elsif Enable='1' Then

          -- Signal Bot1 default value:
          new_value := 0;

          -- Bot1 action on place pl_2(p_2)
          If p_2 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Bot1 action on place pl_5(p_5)
          If p_5 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot1 and check result range:
          If new_value < 0 Then s_Bot1 <= '0';
            Elsif new_value > 1 Then s_Bot1 <= '1';
            Else s_Bot1 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot2 default value:
          new_value := 0;

          -- Bot2 action on place pl_2_2(p_10)
          If p_10 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Bot2 action on place pl_5_2(p_13)
          If p_13 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot2 and check result range:
          If new_value < 0 Then s_Bot2 <= '0';
            Elsif new_value > 1 Then s_Bot2 <= '1';
            Else s_Bot2 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal Bot3 default value:
          new_value := 0;

          -- Bot3 action on place pl_2_3(p_18)
          If p_18 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- Bot3 action on place pl_5_3(p_21)
          If p_21 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store Bot3 and check result range:
          If new_value < 0 Then s_Bot3 <= '0';
            Elsif new_value > 1 Then s_Bot3 <= '1';
            Else s_Bot3 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal movei default value:
          new_value := 0;

          -- movei action on place pl_2_4(p_26)
          If p_26 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- movei action on place pl_5_4(p_29)
          If p_29 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei and check result range:
          If new_value < 0 Then s_movei <= '0';
            Elsif new_value > 1 Then s_movei <= '1';
            Else s_movei <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal movei_2 default value:
          new_value := 0;

          -- movei_2 action on place pl_2_5(p_34)
          If p_34 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- movei_2 action on place pl_5_5(p_37)
          If p_37 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei_2 and check result range:
          If new_value < 0 Then s_movei_2 <= '0';
            Elsif new_value > 1 Then s_movei_2 <= '1';
            Else s_movei_2 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal movei_3 default value:
          new_value := 0;

          -- movei_3 action on place pl_2_6(p_42)
          If p_42 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- movei_3 action on place pl_5_6(p_45)
          If p_45 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store movei_3 and check result range:
          If new_value < 0 Then s_movei_3 <= '0';
            Elsif new_value > 1 Then s_movei_3 <= '1';
            Else s_movei_3 <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal in1_o default value:
          new_value := 0;

          -- in1_o action on place pl_2_7(p_50)
          If p_50 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- in1_o action on place pl_5_7(p_53)
          If p_53 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store in1_o and check result range:
          If new_value < 0 Then s_in1_o <= '0';
            Elsif new_value > 1 Then s_in1_o <= '1';
            Else s_in1_o <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal ini_o default value:
          new_value := 0;

          -- ini_o action on place pl_2_8(p_58)
          If p_58 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- ini_o action on place pl_5_8(p_61)
          If p_61 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store ini_o and check result range:
          If new_value < 0 Then s_ini_o <= '0';
            Elsif new_value > 1 Then s_ini_o <= '1';
            Else s_ini_o <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal outi_o default value:
          new_value := 0;

          -- outi_o action on place pl_2_9(p_66)
          If p_66 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- outi_o action on place pl_5_9(p_69)
          If p_69 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store outi_o and check result range:
          If new_value < 0 Then s_outi_o <= '0';
            Elsif new_value > 1 Then s_outi_o <= '1';
            Else s_outi_o <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal ini_2_o default value:
          new_value := 0;

          -- ini_2_o action on place pl_2_10(p_74)
          If p_74 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- ini_2_o action on place pl_5_10(p_77)
          If p_77 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store ini_2_o and check result range:
          If new_value < 0 Then s_ini_2_o <= '0';
            Elsif new_value > 1 Then s_ini_2_o <= '1';
            Else s_ini_2_o <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal outi_2_o default value:
          new_value := 0;

          -- outi_2_o action on place pl_2_11(p_82)
          If p_82 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- outi_2_o action on place pl_5_11(p_85)
          If p_85 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store outi_2_o and check result range:
          If new_value < 0 Then s_outi_2_o <= '0';
            Elsif new_value > 1 Then s_outi_2_o <= '1';
            Else s_outi_2_o <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal ini_3_o default value:
          new_value := 0;

          -- ini_3_o action on place pl_2_12(p_90)
          If p_90 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- ini_3_o action on place pl_5_12(p_93)
          If p_93 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store ini_3_o and check result range:
          If new_value < 0 Then s_ini_3_o <= '0';
            Elsif new_value > 1 Then s_ini_3_o <= '1';
            Else s_ini_3_o <= conv_std_logic_vector(new_value,1)(0);
          End If;

          -- Signal outi_3_o default value:
          new_value := 0;

          -- outi_3_o action on place pl_2_13(p_98)
          If p_98 > 0 Then
            exp_res := 0;
            If (TRUE)
              Then new_value := exp_res;
            End If;
          End If;

          -- outi_3_o action on place pl_5_13(p_101)
          If p_101 > 0 Then
            exp_res := 1;
            If (TRUE) and
               (ABS(exp_res - 0) > ABS(new_value - 0))
              Then new_value := exp_res;
            End If;
          End If;

          -- Store outi_3_o and check result range:
          If new_value < 0 Then s_outi_3_o <= '0';
            Elsif new_value > 1 Then s_outi_3_o <= '1';
            Else s_outi_3_o <= conv_std_logic_vector(new_value,1)(0);
          End If;

        End If;
      End If;
    End PROCESS;

    Bot1 <= s_Bot1;
    Bot2 <= s_Bot2;
    Bot3 <= s_Bot3;
    movei <= s_movei;
    movei_2 <= s_movei_2;
    movei_3 <= s_movei_3;
    in1_o <= s_in1_o;
    ini_o <= s_ini_o;
    outi_o <= s_outi_o;
    ini_2_o <= s_ini_2_o;
    outi_2_o <= s_outi_2_o;
    ini_3_o <= s_ini_3_o;
    outi_3_o <= s_outi_3_o;

End Structural;
